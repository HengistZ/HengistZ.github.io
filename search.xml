<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>软件工程导论学习笔记</title>
      <link href="/2023/03/21/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/03/21/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="软件工程导论"><a href="#软件工程导论" class="headerlink" title="软件工程导论"></a>软件工程导论</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>软件 &#x3D; 程序 + 数据 + 文档</strong></p><p><strong>程序</strong>：按照事先设定的<strong>功能</strong>和<strong>性能</strong>需求执行的指令序列</p><p>​<strong>程序 &#x3D; 数据结构 + 算法</strong></p><p><strong>数据</strong>：程序能正常操纵的信息的数据结构</p><p>​<strong>数据结构</strong>：计算机中存在一种或多种特定关系的数据元素的集合</p><p><strong>文档</strong>：与程序开发、维护和使用有关的图文材料</p><p><strong>软件本质：以计算为核心手段实现应用目标的解决方案</strong></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p><strong>抽象性</strong>：不可见、无磨损</p><p><strong>一致性</strong>：依附于一定的环境（硬件、网络、技术、接口等）</p><p><strong>持续变更性</strong>：易拷贝、易修改</p><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p>​1946计算机诞生，软件被发明，采用机器语言或汇编语言</p><p>​六十年代，大容量高速计算机诞生，系统规模与复杂度提升，发生</p><h4 id="软件危机："><a href="#软件危机：" class="headerlink" title="软件危机："></a>软件危机：</h4><ul><li>开发进度失控</li><li>开发成本失控</li><li>产品质量失控、可靠性差</li><li>产品难以维护</li></ul><p>​为了达到降低软件生产成本 、改进软件产品质量、提高软件生产率水平的目标，1968北约科学委员会提出</p><h4 id="软件工程学科："><a href="#软件工程学科：" class="headerlink" title="软件工程学科："></a>软件工程学科：</h4><ul><li><strong>研究软件生产的客观规律性</strong></li><li><strong>建立与系统化软件生产有关的概念、原则、方法、技术和工具</strong></li><li><strong>将系统化的、规范的、可度量的方法用于软件的开发、运行和维护的过程</strong></li><li><strong>将工程化应用于软件的开发中，指导和支持软件系统的生产活动</strong></li></ul><h4 id="科学、技术、工程的区别："><a href="#科学、技术、工程的区别：" class="headerlink" title="科学、技术、工程的区别："></a>科学、技术、工程的区别：</h4><ul><li><strong>科学</strong>：发现和解释自然或社会现象 <em>“是什么、为什么”</em></li><li><strong>技术</strong>：运用经验、技巧创造解决问题的工具 <em>“用什么来做”</em></li><li><strong>工程</strong>：运用技术进行设计和规范解决复杂、实际问题 <em>“怎么做更好”</em></li></ul><h2 id="软件过程"><a href="#软件过程" class="headerlink" title="软件过程"></a>软件过程</h2><p>​从软件项目需求定义开始直至软件经使用后废弃为止跨越整个生存期内的系统开发、运行和维护及相关项的总和</p><h4 id="四项基本活动"><a href="#四项基本活动" class="headerlink" title="四项基本活动"></a>四项基本活动</h4><ul><li><strong>软件规格说明</strong>：客户和工程师对软件进行定义和运行的约束</li><li><strong>软件开发</strong>：对软件进行设计与编程实现</li><li><strong>软件确认</strong>：对软件进行检查与确认</li><li><strong>软件演化</strong>：随客户与市场需求变化对软件进行修改</li></ul><h3 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h3><p>![image-20230218170438337](E:\Program Files (x86)\typora\images\软件工程导论\image-20230218170438337.png)</p><p><strong>计划 &lt;-&gt; 需求分析 &lt;-&gt; 设计 &lt;-&gt; 编码 &lt;-&gt; 测试 &lt;-&gt; 运行维护</strong><br><strong>（定义阶段）                     （开发阶段）     （维护阶段）</strong></p><p><strong>特点</strong>：自上而下，相互衔接，适用于<strong>较为明确和稳定的需求</strong></p><h3 id="原型模型"><a href="#原型模型" class="headerlink" title="原型模型"></a>原型模型</h3><p>![image-20230218170354366](E:\Program Files (x86)\typora\images\软件工程导论\image-20230218170354366.png)</p><p><strong>需求分析 -&gt; 原型设计 -&gt; 演示原型 -&gt; 用户评价 -&gt; 构造产品 -&gt; 交付使用</strong><br><strong>重新修改补充需求&lt;– 用户不满意</strong></p><p><strong>特点</strong>：在过程中逐步认知和明晰需求，<strong>减少了需求不明确带来的风险</strong></p><h3 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h3><p>![image-20230218170338796](E:\Program Files (x86)\typora\images\软件工程导论\image-20230218170338796.png)</p><p><strong>从内到外：</strong></p><p><strong>原型1 -&gt; 需求计划 -&gt; 风险分析</strong></p><p><strong>原型2 -&gt; 需求确认 -&gt; 开发计划 -&gt; 风险分析</strong></p><p><strong>原型3 -&gt; 产品设计 -&gt; 设计确认 -&gt;组装测试 -&gt; 风险分析</strong></p><p>**可运行原型 -&gt; 详细设计 -&gt; 编码、单元测试、组装、验收……  **</p><p><strong>特点</strong>：<strong>迭代演化、在每次循环加入风险分析，适用于不明确且不稳定的需求</strong></p><h3 id="增量模型"><a href="#增量模型" class="headerlink" title="增量模型"></a>增量模型</h3><p>![image-20230218170317373](E:\Program Files (x86)\typora\images\软件工程导论\image-20230218170317373.png)</p><p><strong>线性过程+并行过程</strong></p><p><strong>沟通 -&gt; 策划 -&gt; 建模（分析设计） -&gt; 构建（编码测试） -&gt; 部署（交付反馈）</strong><br><strong>（开启后一个增量的沟通）</strong></p><p><strong>特点</strong>：第一个增量是核心产品、<strong>并行化效率提升</strong>，适用于需求较不稳定且 <strong>强调快速交付</strong>的产品</p><h2 id="需求工程"><a href="#需求工程" class="headerlink" title="需求工程"></a>需求工程</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p><strong>以一种清晰、简洁、一致且无二义性的方式，对一个待开发软件系统中各个有意义的功能，和性能等方面的陈述的一个集合</strong></p><h3 id="需求的层次"><a href="#需求的层次" class="headerlink" title="需求的层次"></a>需求的层次</h3><h4 id="业务需求"><a href="#业务需求" class="headerlink" title="业务需求"></a>业务需求</h4><h4 id="用户需求"><a href="#用户需求" class="headerlink" title="用户需求"></a>用户需求</h4><h4 id="系统需求"><a href="#系统需求" class="headerlink" title="系统需求"></a>系统需求</h4><h3 id="功能性需求"><a href="#功能性需求" class="headerlink" title="功能性需求"></a>功能性需求</h3><p><strong>对系统应该提供的服务、系统应当如何响应特定的输入、系统在特定情形中该如何表现的陈述</strong></p><h2 id="非功能性需求"><a href="#非功能性需求" class="headerlink" title="非功能性需求"></a>非功能性需求</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>软件在<strong>运行时是否好用</strong>、<strong>执行速度是否足够快</strong>、<strong>故障率是否足够低</strong>、<strong>意外情况是否得到妥善处理</strong>等需求</p><p>非功能性需求描述了一个软件系统应具备的<strong>属性、特征及其必须遵守的约束</strong></p><h3 id="外部质量属性"><a href="#外部质量属性" class="headerlink" title="外部质量属性"></a>外部质量属性</h3><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>规定条件下系统所用的资源</p><ul><li><strong>时间特性</strong>：响应和处理时间、吞吐量</li><li><strong>资源利用率</strong>：使用资源数量和类别程度</li><li><strong>容量</strong>：满足要求的最大限度</li></ul><h4 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h4><p>规定条件下执行指定功能的程度</p><ul><li><strong>成熟性</strong>：正常操作下满足可靠性的程度</li><li><strong>可用性</strong>：在需要使用时，可操作和可访问的程度</li><li><strong>容错性</strong>：硬件或软件在存在故障时，系统或产品也想预期一样运转的程度</li><li><strong>易恢复性</strong>：在失效发生后重建性能级别和恢复数据的程度</li></ul><h4 id="易用性"><a href="#易用性" class="headerlink" title="易用性"></a>易用性</h4><p>特定使用条件下，特定用户达到满足的有效性、效率和满意度</p><ul><li><strong>适当性&#x2F;可辨认性</strong>：用户是否可以识别产品或系统适合他们的需求的程度</li><li><strong>易学性</strong>：特定使用条件下，特定用户可通过学习使用产品，达到效率和满意度的目标的程度</li><li><strong>易操作性</strong>：产品或系统具有易操作或易控制属性的程度</li><li><strong>用户错误保护</strong>：系统保护用户免受错误的程度</li><li><strong>用户界面美观</strong>：产品界面取悦或满足用户交互的程度</li><li><strong>易接近性</strong>：产品使用的最广泛的特征和功能，在特定使用条件下的效率&#x2F;接近目标的程度</li></ul><h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p>指产品或系统保护信息和数据，以便人员或其他系统的数据访问适当的程度，类型和级别的授权程度</p><ul><li><strong>机密性</strong>：产品或系统确保数据只能被有权之人访问的程度</li><li><strong>完整性</strong>：系统、产品防止未经授权的访问或修改程序或数据的程度、</li><li><strong>不可抵赖性</strong>：动作或事件已经发生，这样的事件和动作不能否定</li><li><strong>问责性</strong>：一个实体的操作可以追溯到唯一实体的程度</li><li><strong>真实性</strong>：一个主体或资源的身份可以被证明是一个声称</li></ul><h4 id="功能适用性"><a href="#功能适用性" class="headerlink" title="功能适用性"></a>功能适用性</h4><p>指产品在特定使用条件下，产品或系统满足明确和隐含要求的功能和程度</p><ul><li><strong>功能的完整性</strong>：功能集覆盖所有规定任务和用户目标的程度</li><li><strong>功能的正确性</strong>：产品或系统提供具有所需精度的正确结果的程度</li><li><strong>功能的适合性</strong>：功能促进指定任务和目标实现的程度</li></ul><h5 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h5><p>共享相同的硬件或软件时，产品执行其所需功能与其它系统交换信息的程度</p><ul><li><strong>共存性</strong>：与其他产品共享环境和资源时，无不利影响情况下，产品有效地执行功能的程度</li><li><strong>互操作性</strong>：指两个或两个以上的系统、产品或部件可以交换信息，并使用已经交换的信息的程度</li></ul><h3 id="内部质量属性"><a href="#内部质量属性" class="headerlink" title="内部质量属性"></a>内部质量属性</h3><h4 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h4><p>系统产品能够扩展，从而轻松处理更多功能的程度</p><ul><li><strong>可修改性</strong>：产品系统能够快速地以较高的性价比对系统进行变更的能力</li></ul><h4 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h4><p>系统产品从一种软硬件环境移植到另一种的有效性和效率程度</p><ul><li><strong>适应性</strong>：有效的适用于另一种软硬件环境</li><li><strong>易安装性</strong>：在指定环境下可以成功安装&#x2F;卸载的的有效性和效率程度</li><li><strong>易替换性</strong>：在相同的环境下，替代另一个相同用途的指定软件产品的程度</li></ul><h4 id="可维护性"><a href="#可维护性" class="headerlink" title="可维护性"></a>可维护性</h4><p>维护者可以修改产品或系统的有效性和效率的程度</p><ul><li><strong>模块化</strong>：系统或程序由单个元件组成，改变一个对其他组件影响程度很小</li><li><strong>可重用性</strong>：有利条件可以用在一个及以上的系统，或建立其他有用的程度</li><li><strong>易分析性</strong>：评估一个产品或系统拟改变期中一个或多个组件的影响，或诊断软件中失效的原因或识别待修改部分的有效性和效率程度</li><li><strong>可变性</strong>：指产品或系统可以有效和高效地修改，而不会引入缺陷或降解的现有产品质量的程度</li><li><strong>易测性</strong>：指建立系统、产品和组件的测试标准的有效性和效率的程度</li></ul><h3 id="外部接口需求"><a href="#外部接口需求" class="headerlink" title="外部接口需求"></a>外部接口需求</h3><p>确保软件产品能够与外部组件正确的连接</p><ul><li><strong>用户界面</strong>：</li><li><strong>硬件接口</strong>：</li><li><strong>软件接口</strong>：</li><li><strong>通讯接口</strong>：</li></ul><h3 id="开发约束需求"><a href="#开发约束需求" class="headerlink" title="开发约束需求"></a>开发约束需求</h3><p><strong>开发成本、交付进度、技术选型、遵循标准等方面提出的要求</strong></p><ul><li>必须使用或避免特定技术、工具、语言和数据库</li><li>软件产品的操作环境或平台</li><li>遵循特定的开发惯例或标准</li><li>前向兼容和后向兼容</li><li>法律法规或其他商业规则要求</li><li>时间要求、内存或处理器限制、尺寸、重量、材料或成本</li></ul><h2 id="敏捷过程"><a href="#敏捷过程" class="headerlink" title="敏捷过程"></a>敏捷过程</h2><p>互联网发展后，需求日趋复杂、技术日新月异、市场变幻莫测，软件工程给需要<strong>在市场许可的期限内利用有限资源生产出满足需求的产品</strong>：</p><p>​<strong>利用流程活动(时序逻辑关系)+ 流程活动各要素 (如人员、方法、产品等)</strong></p><p>2001年2月，“敏捷联盟（ The Agile Alliance ）”中17位方法学家达成共识，制定了“**敏捷软件开发宣言(敏捷宣言 Agile Manifesto)**”</p><p>![image-20230218170233419](E:\Program Files (x86)\typora\images\软件工程导论\image-20230218170233419.png)</p><h3 id="敏捷宣言四条价值观"><a href="#敏捷宣言四条价值观" class="headerlink" title="敏捷宣言四条价值观"></a>敏捷宣言四条价值观</h3><p><strong>个体和交互重于过程和工具</strong></p><p>Individuals and interactions over processes and tools.</p><p><strong>可工作的软件重于面面俱到的文档</strong></p><p>Working software over comprehensive documentation.</p><p><strong>客户合作重于合同谈判</strong></p><p>Customer colleboration over contract negotiation</p><p><strong>响应变化重于尊重计划</strong></p><p>Responding to change over following a plan</p><p>虽然右项也具有价值，但我们认为左项具备更大的价值</p><p>That is, while there is value in the item on the right, we value the items on the right more.</p><p>Kent Beck, James Grenning, Robert C.Martin, Mike Beedle,<br>Jim Highsmith, Steve Mellor, Arie Van Bennekum, Andrew Hunt,<br>Ken Schwaber, Alistair Cockburn, Ron Jeffries, Jeff Sutherland,<br>Ward Cunningham, Jon Kern, Dave Thomas, Martin Fowler, Brian Marick</p><h3 id="敏捷过程12条原则"><a href="#敏捷过程12条原则" class="headerlink" title="敏捷过程12条原则"></a>敏捷过程12条原则</h3><ol><li>最优先要做的是通过尽早地、持续地交付有价值的软件来使客户满意。</li><li>即使到了开发后期，也欢迎改变需求，敏捷过程利用变化来为客户创造</li><li>经常性交付可以工作的软件，交付的时间间隔越短越好</li><li>在整个项目开发期间，商务人员和开发人员必须天天工作在一起</li><li>围绕被激励起来的个体来构建项目，给他们提供所需的环境和支持，并且信任他们能够完成工作</li><li>在团队内部，最具有效果且富有效率的信息传递方法，就是面对面交谈</li><li>工作的软件是首要的进度度量标准</li><li>敏捷过程提倡可持续的开发速度，责任人、开发者和用户应该能够保持一个长期的、恒定的开发速度</li><li>不断地关注优秀设计的技能和好的设计会增强敏捷能力</li><li>Make it simple</li><li>最好的架构、需求和设计出自于自组织的团队</li><li>每隔一段时间，团队会在如何才能更有效地工作方面进行反省，然后响应地对自己的行为进行调整</li></ol><h2 id="统一过程"><a href="#统一过程" class="headerlink" title="统一过程"></a>统一过程</h2><p>![image-20230218170546134](E:\Program Files (x86)\typora\images\软件工程导论\image-20230218170546134.png)</p><p>1998年Rational公司面向对象领域三位杰出专家及UML创立者（Grady Booch、James  Rumbaugh、Ivar Jacobson）提出了统一过程的概念</p><p><strong>Rational统一过程（Rational Unified Process，RUP）：迭代与增量生命周期模型</strong></p><p>对于每个结构：均涉及<strong>人员、方法、产品</strong>等要素</p><h3 id="动态结构"><a href="#动态结构" class="headerlink" title="动态结构"></a>动态结构</h3><p><strong>横轴：生命周期四个阶段</strong></p><p>其中，每个阶段均会<strong>进行若干次的迭代</strong></p><h4 id="先启阶段"><a href="#先启阶段" class="headerlink" title="先启阶段"></a>先启阶段</h4><p>目标：建立业务用例、确定项目的边界</p><p>结束里程碑：生命周期目标里程碑</p><h4 id="精化阶段"><a href="#精化阶段" class="headerlink" title="精化阶段"></a>精化阶段</h4><p>目标：建立稳定的构架、编制项目计划、淘汰项 目中最高风险的元素</p><p>结束里程碑：生命周期构架里程碑</p><h4 id="构建阶段"><a href="#构建阶段" class="headerlink" title="构建阶段"></a>构建阶段</h4><p>目标：所有构件和应用程序功能被开发并集成为 产品、所有的功能被详尽的测试</p><p>结束里程碑：最初操作性能里程碑</p><h4 id="产品化阶段"><a href="#产品化阶段" class="headerlink" title="产品化阶段"></a>产品化阶段</h4><p>目标：将软件产品交付给用户群体</p><p>结束里程碑：产品发布里程碑</p><h3 id="静态结构"><a href="#静态结构" class="headerlink" title="静态结构"></a>静态结构</h3><p><strong>纵轴：生命周期九个核心工作流程</strong></p><p><strong>核心过程工作流程：</strong></p><h4 id="业务建模"><a href="#业务建模" class="headerlink" title="业务建模"></a>业务建模</h4><p><strong>描述如何拟定客户组织的前景，并基于该前景来确定业务用例模型和业务对象模型中的流程、角色以及职责</strong></p><p>人员：业务流程分析员、业务设计员、业务模型复审员</p><p>工件：业务模型（用例图+对象模型）</p><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p><strong>描述系统应该做什么，即捕获需求，并使开 发人员和用户就这一需求描述达成共识。</strong></p><p>人员：系统分析员（需求工程师）、用户界面设计师（UI）、需求复审员</p><p>工件：用例模型（用例文档）、用户界面模型（原型界面）</p><h4 id="分析设计"><a href="#分析设计" class="headerlink" title="分析设计"></a>分析设计</h4><p><strong>将需求转化成未来系统的设计，为系统开发一个健壮的结构并调整设计使其与实现环境相匹配，优化其性能。</strong></p><p>人员：架构设计师（架构师）、架构复审员、设计员、数据库设计员、设计复审员</p><p>工件：产品架构设计模型（子系统、类图）</p><h4 id="实现（实施）"><a href="#实现（实施）" class="headerlink" title="实现（实施）"></a>实现（实施）</h4><p>以构件的形式(源文件、二进制文件、可执行文件) 实现类和对象并测试；<br>以层次化的子系统形式定义代码的组织结构；<br>将各实施员完成的结果集成到可执行系统中。</p><p>人员：架构设计师、程序员、集成员、代码复审员</p><p>工件：实施模型（程序主体）</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>验证产品的功能和性能，如对象间的交互作用、 所有构件是否正确集成、所有的需求是否已被正确的实现，识别确认缺陷并确保在部署前解决之。</p><p>人员：测试设计员、测试员</p><p>工件：测试模型（测试报告）+测试结果</p><h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><p>描述了三种产品部署的模式：包括自定义安装、 市售和通过Internet使用软件；在每种模式中，都强调要在开发场所对产品进行测试，并在产品最终发布 之前进行Beta测试。</p><p>人员：部署经理、程序员、技术文档编写员、课程开发员</p><p>工件：产品的一个版本、文档培训资料</p><p><strong>核心支持工作流程：</strong></p><h4 id="配置与变更管理"><a href="#配置与变更管理" class="headerlink" title="配置与变更管理"></a>配置与变更管理</h4><p>描绘如何在多个成员组成的项目中控制大量的产物， 并提供了准则来管理演化系统中的多个变体，跟踪软件 创建过程中的版本</p><p>人员：配置经理、变更控制经理、集成员</p><p>工件：配置管理计划、变更请求、项目存储库和工作区</p><h4 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h4><p>平衡竞争的目标、管理风险并克服各种约束，从而 成功交付使用户满意的产品，包括为项目的管理提供 框架，为计划、人员配备、执行和监控项目提供实用 的准则，为管理风险提供框架等</p><p>人员：项目经理、项目复审员</p><p>工件：商业理由、迭代计划、风险管理计划、质量保证计划及相应的评估文档</p><h4 id="环境搭建与管理"><a href="#环境搭建与管理" class="headerlink" title="环境搭建与管理"></a>环境搭建与管理</h4><p>向软件开发组织提供软件开发的环境，包括过程和 工具</p><p>人员：过程工程师、工具专家</p><p>工件：工具及工具指南、工作流程指南</p><h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><h3 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h3><p><strong>定义</strong>：用例是对一个参与者(actor)使用 系统的一项功能时所进行的交互过程的一 个文字描述序列。</p><p><strong>要点</strong>：</p><ul><li>可观测→用例止于系统边界</li><li>结果值→用例是有意义的目标</li><li>系统执行→结果值由系统生成</li><li><strong>由参与者观测→业务语言、用户观点</strong>：<br>处理订票错，订票对；显示XXX错，查看XXX对</li></ul><p>![image-20230218165400184](E:\Program Files (x86)\typora\images\软件工程导论\image-20230218165400184.png)</p><h4 id="泛化关系"><a href="#泛化关系" class="headerlink" title="泛化关系"></a>泛化关系</h4><p>泛化（generalization）代表一般与特殊的关系。</p><p>泛化的意思与OO程序设计中的继承概念类似，在分析和设计阶段，用泛化术语较多一些</p><h4 id="包含关系（必须）"><a href="#包含关系（必须）" class="headerlink" title="包含关系（必须）"></a>包含关系（必须）</h4><p>包含（include）指的是两个用例间的关系，其中一个用例（称作基本用例）的行为包含了另一个用例（称作包含用例）的行为</p><h4 id="扩展关系（可选）"><a href="#扩展关系（可选）" class="headerlink" title="扩展关系（可选）"></a>扩展关系（可选）</h4><p>扩展（extend）指的是一个用例可以增强另一个用例的 行为，扩展用例提供了一个离散的行为 ,可以将自己添加 到基用例中</p><p>![image-20230218170146770](E:\Program Files (x86)\typora\images\软件工程导论\image-20230218170146770.png)</p><p>例：健康码区县防疫办用例图</p><p>![image-20230218171301297](E:\Program Files (x86)\typora\images\软件工程导论\image-20230218171301297.png)</p><p>核酸检测机构用例图：</p><p>![image-20230218171421322](E:\Program Files (x86)\typora\images\软件工程导论\image-20230218171421322.png)</p><h3 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h3><h4 id="要素"><a href="#要素" class="headerlink" title="要素"></a>要素</h4><p><strong>事件</strong>：对一个在时间和空间上占有 一定位置的有意义的事情的详细说明</p><p><strong>状态</strong>：对象（类）生命周期的一个阶段，在该阶 段中该对象要满足一些特定的条件，并可从事特 定的活动</p><p><strong>动作</strong>：可执行的原子计算。也就是说， 动作是不可中断的，其执行时间可忽略不计。</p><p><strong>转换</strong>：是两个状态之间的一种关系，表示当一个特定的事件出现时，如果满 足一定的条件，对象就从第一个状态（源状态）进入第二个状态（目 标状态），并执行一定的动作。转换本身也是原子的</p><p>![image-20230218170943872](E:\Program Files (x86)\typora\images\软件工程导论\image-20230218170943872.png)</p><h3 id="活动图"><a href="#活动图" class="headerlink" title="活动图"></a>活动图</h3><p>活动还有其它的图符：初态、终态、判断、<strong>同步（并发）</strong></p><p>![image-20230218171737245](E:\Program Files (x86)\typora\images\软件工程导论\image-20230218171737245.png)</p><p>例：区县防疫办活动图</p><p>![image-20230218172139766](E:\Program Files (x86)\typora\images\软件工程导论\image-20230218172139766.png)</p><h4 id="泳道图"><a href="#泳道图" class="headerlink" title="泳道图"></a>泳道图</h4><p>泳道是活动图 中的区域划分， 根据每个活动 的职责对所有 活动进行划分， 每个泳道代表 一个责任区</p><p>![image-20230218172346092](E:\Program Files (x86)\typora\images\软件工程导论\image-20230218172346092.png)</p><p>![image-20230218172354389](E:\Program Files (x86)\typora\images\软件工程导论\image-20230218172354389.png)</p><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><h4 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h4><p><strong>聚合关系</strong>：描述“整体-部分”的关 联关系，聚合关系没有改变整体 与部分之间整个关联的 导航含义，也与整体和 部分的生命周期无关</p><p>![image-20230218173302967](E:\Program Files (x86)\typora\images\软件工程导论\image-20230218173302967.png)</p><p><strong>组合关系</strong>：组合关系中的部分要完 全依赖于整体</p><p>![image-20230218173309933](E:\Program Files (x86)\typora\images\软件工程导论\image-20230218173309933.png)</p><p><strong>实现关系</strong>：实现关系用来表示规格说明与实现之间的关系。在类 图中，实现关系主要用于接口与实现该接口的类之间</p><p>![image-20230218173351792](E:\Program Files (x86)\typora\images\软件工程导论\image-20230218173351792.png)</p><p>例如：普通用户类图</p><p>![image-20230218173027876](E:\Program Files (x86)\typora\images\软件工程导论\image-20230218173027876.png)</p><p>![image-20230218173034218](E:\Program Files (x86)\typora\images\软件工程导论\image-20230218173034218.png)</p><p>健康码类图：</p><p>![image-20230218173127473](E:\Program Files (x86)\typora\images\软件工程导论\image-20230218173127473.png)</p><h3 id="时序图-x2F-顺序图"><a href="#时序图-x2F-顺序图" class="headerlink" title="时序图&#x2F;顺序图"></a>时序图&#x2F;顺序图</h3><h4 id="顺序图的三种主要作用："><a href="#顺序图的三种主要作用：" class="headerlink" title="顺序图的三种主要作用："></a>顺序图的三种主要作用：</h4><ul><li>细化用例的表达。本章前面我们已经提到，使用顺 序图的一大用途，就是讲用例所描述的需求与功能 转化为更加正式、层次更加分明的细化表达。</li><li>有效地描述类职责的分配方式。我们可以根据顺序 图中各对象之间的交互关系和发送的消息来进一步 明确对象所属类的职责。</li><li>丰富系统的使用语境的逻辑表达。系统的使用语境 即为系统可能的使用方式和使用环境。</li></ul><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>顺序图中的对象与对象图中 的概念一样，都是类的实例 。顺序图中的对象可以是系 统的参与者或者任何有效的 系统对象。</p><h4 id="生命线"><a href="#生命线" class="headerlink" title="生命线"></a>生命线</h4><p>生命线代表了一次交互中的 一个参与对象在一段时间内 存在。具体地说，在生命线 所代表的时间内，对象一直 是可以被访问的——可以随 时发送消息给它</p><h4 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h4><p>激活，又称为控制焦点，表示 一个对象执行一个动作所经历 的时间段，既可以是直接执行 ，也可以是安排下级过程执行 。同时，激活也可以表示对应 对象在这段时间内不是空闲的 ，它正在完成某个任务，或正 被占用</p><h4 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h4><p>消息是从一个对象（发送者）向另一个对象 （接收者）发送信号，或由一个对象（发送 者或调用者）调用另一个对象（接收者）的 操作</p><p>例：健康码申诉时序图</p><p>![image-20230218172643938](E:\Program Files (x86)\typora\images\软件工程导论\image-20230218172643938.png)</p><p>区县防疫办变码时序图</p><p>![image-20230218172728498](E:\Program Files (x86)\typora\images\软件工程导论\image-20230218172728498.png)</p><p>普通用户查看个人信息</p><p>![image-20230218173809594](E:\Program Files (x86)\typora\images\软件工程导论\image-20230218173809594.png)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统个人向笔记</title>
      <link href="/2023/03/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E4%B8%AA%E4%BA%BA%E5%90%91%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/03/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E4%B8%AA%E4%BA%BA%E5%90%91%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><strong>数据库：</strong> 由一个<strong>数据库管理系统</strong>(DBMS, Database Management System)所管理的一个<strong>数据集合</strong></p><p><strong>数据库管理系统</strong>：<br>功能：<strong>持久的大量的数据存储、用户接口和编程接口、事务管理</strong>（共享数据：多用户并发访问避免互相影响和损坏数据）<br>举例：Oracle, MySQL</p><p><strong>数据定义语言(DDL, Data Definition Language):</strong> 创建数据库并确定其模式(Schema)。</p><p><strong>数据库模式(Schema):</strong> 是一组用DDL表达的语句集合描述的数据库逻辑结构。<br>数据独立性依靠模式分级及模式之间的影像实现。</p><p><strong>数据查询语言(DQL, Data Query Language)、数据操作语言(DML, Data Manipulation Language):</strong> 依据数据库模式查询或更新数据</p><h2 id="有关数据库的三方面工作"><a href="#有关数据库的三方面工作" class="headerlink" title="有关数据库的三方面工作"></a>有关数据库的三方面工作</h2><p><strong>设计(design):</strong> 如何建立一个有用的数据库。需求分析，数据建模，关系设计。</p><p><strong>编程(programming):</strong> 在数据库设计基础上，如何进行各种查询和计算操作。</p><p><strong>实现:implementation):</strong> 如何构建一个数据库管理系统(DBMS)，独立于特定应用</p><h1 id="数据库管理系统结构"><a href="#数据库管理系统结构" class="headerlink" title="数据库管理系统结构"></a>数据库管理系统结构</h1><h2 id="查询指令、数据及模式更新指令传入查询处理器"><a href="#查询指令、数据及模式更新指令传入查询处理器" class="headerlink" title="查询指令、数据及模式更新指令传入查询处理器"></a>查询指令、数据及模式更新指令传入查询处理器</h2><p><img src="https://img-blog.csdnimg.cn/28de813773a841e5a77b20ff2df3652e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASGVuZ2lzdF9a,size_14,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h2 id="数据存储器："><a href="#数据存储器：" class="headerlink" title="数据存储器："></a>数据存储器：</h2><p>存储数据和元数据，文件是主要方式 。</p><p>**元数据(metadata)**：关于数据的结构的信息。数据按元数据规范的格式存储。</p><p>**索引(index)**：一种数据结构，以快速查找数据项(item)<br>索引是数据的一部分，而对索引的说明则是元数据的一部分。</p><p>Hash表是早期建立索引的主要方法，现一般使用B(Balance)树。</p><h2 id="存储管理器"><a href="#存储管理器" class="headerlink" title="存储管理器"></a>存储管理器</h2><p>对数据读写进行管理，包含<strong>文件管理</strong>和<strong>缓冲区管理</strong>。依赖于特定操作系统</p><p><strong>文件(files)管理：</strong> 磁盘文件分块(1~16K)</p><p><strong>缓冲区(buffer)管理：</strong> 文件到内存的映像(1~4K)</p><h2 id="查询处理器"><a href="#查询处理器" class="headerlink" title="查询处理器"></a>查询处理器</h2><p>将SQL的命令预处理，将其转变为对存储数据的操作序列</p><p>主要问题是优化</p><h2 id="事物管理器"><a href="#事物管理器" class="headerlink" title="事物管理器"></a>事物管理器</h2><p>负责系统数据的完整性。保证并发运行的多个SQL命令的相互独立、保证数据的安全性。</p><p>操作日志(log)</p><p><strong>事物(Transaction):</strong> 一组操作作为一个单元，按次序全部执行。<br>事物的特性：ACID</p><ol><li><strong>原子性(Atomicity):</strong> 一组操作要么全部执行，要么都不执行。</li><li><strong>一致性(Consistency):</strong> 确保操作的正确执行</li><li><strong>隔离性(Isolation):</strong> 多个事物并发运行时相互独立</li><li><strong>持久性(Durability):</strong> 事物完成后即保存不会丢失</li></ol><p>通过 <strong>加锁(locking)</strong> 、 <strong>日志(logging)</strong> 和 <strong>提交(commit)</strong> 等方式保持事务特性</p><p><img src="https://img-blog.csdnimg.cn/4651821540934ed98122da27be486258.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASGVuZ2lzdF9a,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br><strong>客户端Client:</strong> 请求SQL服务的软件进程。<br><strong>服务器Server:</strong> 提供SQL服务的软件进程。<br>一个服务器可支持多个数据库；一个数据库包含多个关系。</p><h1 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h1><p><strong>数据模型(Data model)是用于描述数据或信息的标记</strong></p><p>一般由三部分组成：<strong>数据结构(Structure of the data)、操作系统(Operation on the data)、数据上的约束(Constraint on the data)</strong></p><p>两种典型数据模型：<strong>关系数据模型、半结构化数据模型(XML)</strong></p><h2 id="关系数据模型"><a href="#关系数据模型" class="headerlink" title="关系数据模型"></a>关系数据模型</h2><p><strong>一种基于表的数据模型</strong><br>由关系数据模型衍生出的面向表的操作集合是<strong>关系代数</strong><br>是数据库管理系统采用的最多的一种数据模型。</p><p><strong>高效性和易用性：</strong></p><ol><li>提供简单有效的方法对数据进行建模，而且功能全面.</li><li>提供了一套有限但很有效的操作集合</li><li>可以使用高级的程序语言</li></ol><p>例如：<br><img src="https://img-blog.csdnimg.cn/653e63ee22a74fd5b4a349432c6ceec1.png#pic_center" alt="在这里插入图片描述"></p><p><strong>关系名:</strong> 整张表的名字，例如上图为“movie”</p><p><strong>属性:</strong> （列名）在每一列的顶部(Head)为该列命名。</p><p><strong>关系模式:</strong> 关系名及属性的集合，也是关系数据库的模式(Schema)<br>表示方法：<code>Movies(title，year，length，genre);</code></p><p><strong>元组:</strong> 除第一行外其余的行<br>表示方法：<code>(Gone with the wind，1939，231，drama);</code></p><p><strong>域:</strong> 包含某一列任一分量值的一种不可分割的元素类型，例如：interger或string</p><ol><li>可变长度或固定长度字符串。</li><li>固定或可变长度的位串。</li><li>BOOLEAN表示具有逻辑类型的值。</li><li>类型INT和INTEGER表示典型的整数值。</li><li>浮点值能通过不同的方法表示。</li><li>日期和时间分别通过DATA和TIME数据类型来表示。<br>包含域的关系模式：<code>Movies(title：string，year：integer，length：integer，genre：string);</code></li></ol><p><strong>关系:</strong> 元组的集合，而不是列表，所以<strong>行的顺序不重要</strong>，同理<strong>列的顺序也不重要</strong>。</p><p><strong>关系的实例:</strong> 在关系给定的情况下元组的集合，当前关系的实例被称为当前实例。</p><p><strong>键(key):</strong> 关系中一个或多个属性的集合，保证关系实例中任意两个元组在该属性集上的取值不同。<br>键通过属性下划线表示：<code>Movies(title，year，length，genre);</code></p><h2 id="半结构化数据模型"><a href="#半结构化数据模型" class="headerlink" title="半结构化数据模型"></a>半结构化数据模型</h2><p><strong>基于树或者图，而非表或数组</strong></p><p><strong>XML利用一系列分层嵌套的标签元素来表示数据（可理解为一种隐含的树结构）</strong></p><h2 id="其他类型数据模型"><a href="#其他类型数据模型" class="headerlink" title="其他类型数据模型"></a>其他类型数据模型</h2><p>除前两者之外，数据库的数据模型还有：<strong>对象关系模型、纯面向对象的数据库模型、层次模型和网状模型等</strong></p><h1 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h1><p>定义：由关系数据模型衍生出的面向表的操作集合<br>关系代数的表达式被称为<strong>查询</strong></p><h2 id="三个基本操作-并、交、差-："><a href="#三个基本操作-并、交、差-：" class="headerlink" title="三个基本操作(并、交、差)："></a>三个基本操作(并、交、差)：</h2><ol><li><strong>R∪S 表示关系R和S的并，所得到的结果关系的元素是来<br>自R或者S或者在R和S中都出现过，但是对于最后一<br>种情况，结果关系中的这个元素只出现一次。</strong></li><li><strong>R∩S 表示关系R和S的交，就是同时在R和S中存在的元素<br>的集合。</strong></li><li><strong>R – S 是关系R和S的差，它是由在R中但不在S中出现的元<br>素构成的集合</strong></li></ol><p><strong>其中R和S必须是具有同样属性集合的表，各个属性的域(数据类型)也必须相同</strong></p><h2 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h2><p>用于从原关系R选出一部分<strong>列</strong>来生成一个新的关系。</p><p>例如关系Movies<br><img src="https://img-blog.csdnimg.cn/fb1f295d326a471fad6a65086f5d68c1.png" alt="在这里插入图片描述"></p><p>进行了如下操作：<br><img src="https://img-blog.csdnimg.cn/b078a4ffb3f84f3ba486248f70449a3f.png" alt="在这里插入图片描述"></p><p>结果如下：<br><img src="https://img-blog.csdnimg.cn/3a67c8816aa04034a6e4157e6162fea7.png" alt="在这里插入图片描述"></p><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>用于从关系R中选出<strong>元组的子集合</strong>。<br><img src="https://img-blog.csdnimg.cn/d0b744ff87a64e3aab2dcd5604a0db39.png" alt="在这里插入图片描述"><br>其中包含关于属性的条件C，若有多个属性则用<code>AND</code>相连<br>字符串用单引号，大于小于等于均用数学符号<br>例如：<img src="https://img-blog.csdnimg.cn/97f3bc6433d34cf59d4da8b8c30c2d09.png" alt="在这里插入图片描述"></p><h2 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h2><p>又名叉积或者做积，记为R<em>S，得到元组的总数量为R与S元组的数量的*<em>乘积</em></em><br>例如：<img src="https://img-blog.csdnimg.cn/3a92604b039849ffadeb398119ecc4f3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASGVuZ2lzdF9a,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h2><p>表示为：<img src="https://img-blog.csdnimg.cn/846445ddb60f4d148335dc2d74645041.png" alt="在这里插入图片描述"><br>将R与S中有<strong>共同属性</strong>的元组选出并连接</p><h2 id="Θ连接"><a href="#Θ连接" class="headerlink" title="Θ连接"></a>Θ连接</h2><p><img src="https://img-blog.csdnimg.cn/ed277bcaf0504543bc28b3c02638021b.png" alt="在这里插入图片描述"></p><ol><li>先得到R和S的积。</li><li>在得到的关系中寻找满足条件C的元组。</li></ol><p><strong>在关系代数中，可以在子表达式上应用算符来构造新的关系代数表达式，必要的时候用括号把操作数分割开。</strong></p><h2 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h2><p><img src="https://img-blog.csdnimg.cn/17cc2b4e27d54b19a3431d1951ea408f.png" alt="在这里插入图片描述"><br>将关系名从R改为S，属性名依次为A1~An</p><p>简单创建并赋值</p><h1 id="数据库相关编程语言"><a href="#数据库相关编程语言" class="headerlink" title="数据库相关编程语言"></a>数据库相关编程语言</h1><p><strong>可以选中一部分语句执行</strong></p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 这是一行注释</span><br><span class="line"><span class="comment">/* 这是一块注释</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="DDL：数据定义语言"><a href="#DDL：数据定义语言" class="headerlink" title="DDL：数据定义语言"></a>DDL：数据定义语言</h2><h3 id="定义关系："><a href="#定义关系：" class="headerlink" title="定义关系："></a>定义关系：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Movies(</span><br><span class="line">title <span class="type">CHAR</span>(<span class="number">100</span>),</span><br><span class="line"><span class="keyword">year</span> <span class="type">INT</span>,</span><br><span class="line">length <span class="type">INT</span>,</span><br><span class="line">genre <span class="type">CHAR</span>(<span class="number">10</span>),</span><br><span class="line">studioName <span class="type">CHAR</span>(<span class="number">30</span>),</span><br><span class="line">producerC <span class="type">INT</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>若只有一个字符则用CHAR(1)</p><h3 id="删除关系："><a href="#删除关系：" class="headerlink" title="删除关系："></a>删除关系：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> Movies;</span><br></pre></td></tr></table></figure><h3 id="修改属性："><a href="#修改属性：" class="headerlink" title="修改属性："></a>修改属性：</h3><p>使用<code>ALTER TABLE</code>关键词</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Movies <span class="keyword">ADD</span> number <span class="type">CHAR</span>(<span class="number">16</span>);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> MOvies <span class="keyword">DROP</span> genre;</span><br></pre></td></tr></table></figure><h3 id="默认值："><a href="#默认值：" class="headerlink" title="默认值："></a>默认值：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">studioName <span class="type">CHAR</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;unlisted&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="键："><a href="#键：" class="headerlink" title="键："></a>键：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> MovieStar(</span><br><span class="line">name <span class="type">CHAR</span>(<span class="number">30</span>) <span class="keyword">PRIMARY</span> KEY</span><br><span class="line">);</span><br><span class="line">#<span class="keyword">or</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> MovieStar(</span><br><span class="line">name <span class="type">CHAR</span>(<span class="number">30</span>)，</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="DQL：数据查询语言"><a href="#DQL：数据查询语言" class="headerlink" title="DQL：数据查询语言"></a>DQL：数据查询语言</h2><h3 id="限制数据库："><a href="#限制数据库：" class="headerlink" title="限制数据库："></a>限制数据库：</h3><p>在查询语句的开头限制数据库（可以不写）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use 数据库名;</span><br></pre></td></tr></table></figure><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 查询列表 <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure><p>查询列表可能是常量值、表达式、函数（的返回值）；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="number">100</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="string">&#x27;john&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">method</span>();<span class="operator">/</span><span class="operator">/</span>先执行函数再查询返回值</span><br></pre></td></tr></table></figure><p>选中表中所有列：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure><p>可以在列名加上&#96;&#96;，效果相同</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> `name` <span class="keyword">from</span> tableA;</span><br><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> tableA;</span><br></pre></td></tr></table></figure><h4 id="起别名-as"><a href="#起别名-as" class="headerlink" title="起别名: as"></a>起别名: as</h4><p>也可以省略as</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cname <span class="keyword">as</span> <span class="string">&#x27;course name&#x27;</span></span><br><span class="line"><span class="keyword">from</span> courses <span class="keyword">as</span> c;</span><br><span class="line"><span class="keyword">select</span> cname <span class="string">&#x27;course name&#x27;</span></span><br><span class="line"><span class="keyword">from</span> courses c;</span><br></pre></td></tr></table></figure><h4 id="去重：去除查询结果中的重复项"><a href="#去重：去除查询结果中的重复项" class="headerlink" title="去重：去除查询结果中的重复项"></a>去重：去除查询结果中的重复项</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> cno</span><br><span class="line"><span class="keyword">from</span> students;</span><br></pre></td></tr></table></figure><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 查询列表</span><br><span class="line"><span class="keyword">from</span> 表名</span><br><span class="line"><span class="keyword">where</span> 查询条件;</span><br></pre></td></tr></table></figure><p><strong>条件运算符：&gt; &lt; &#x3D;(注意是单等号) !&#x3D; &gt;&lt;(不等于)</strong></p><p><strong>逻辑运算符：and(&amp;&amp;) or(||) not(!)</strong></p><h3 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h3><p><strong>between and</strong><br>包含临界值<br><strong>in</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span> id <span class="keyword">in</span>(<span class="number">1</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>不能使用通配符<br><strong>is null</strong><br>判断是否为空</p><h4 id="like"><a href="#like" class="headerlink" title="like"></a>like</h4><p>包含a的name</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span> `name` <span class="keyword">like</span> <span class="string">&#x27;%a%&#x27;</span></span><br></pre></td></tr></table></figure><p>其中，%是通配符，如果只查开头就去掉前面的%</p><p><strong>通配符：</strong><br>**%**：任意多个字符（可以为0）<br><strong>_</strong> : 任意单个字符<br>如果查询%或者_则需要用转译符</p><p>自定义转义符：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span> `name` <span class="keyword">like</span> <span class="string">&#x27;a$_b&#x27;</span> <span class="keyword">escape</span> <span class="string">&#x27;$&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 查询列表</span><br><span class="line"><span class="keyword">from</span> 表名</span><br><span class="line"><span class="keyword">where</span> 查询条件</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> 列名集合;</span><br></pre></td></tr></table></figure><p>默认升序，降序后加desc</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> 列名集合 <span class="keyword">asc</span>;</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> 列名集合 <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><h3 id="单行函数"><a href="#单行函数" class="headerlink" title="单行函数"></a>单行函数</h3><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>int length(string s) 字符串长度<br><strong>string concat(string s1,string s2,…)</strong> 拼接字符串<br>string upper(string s) string lower(string s) 转大写、转小写<br><strong>string substr(string s, int a, int b) 子串，b可以省略</strong><br><strong>注意：索引从1开始</strong><br>int instr(string s1, string s2)子串的索引<br>sreing trim(string s1 from string s2)去前后s1，s1省略就是去空格<br>string Lpad(string s1 ,int a ,string s2) string Rpad(string s1 ,int a ,string s2)用s2将s1填充到a个字符(左右填充)<br>string replace(string s1 ,string s2 ,string s3)将s1中所有s2替换成s3</p><h4 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h4><p>int round(double a) 四舍五入<br>double round(double a, int n) 保留位数（四舍五入）<br>int ceil(double a)向上取整<br>int floor(double a)向下取整<br>double truncate(double a ,int n)保留位数</p><h4 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h4><p><strong>格式：%Y-%m-%d</strong><br>Date-Time now()返回当前日期和时间<br>Date curdate()返回当前日期<br>Time curtime()返回当前时间<br>int year(Date d)返回年（月、日同理）<br>string monthname(Date d)返回月名字<br><strong>日期格式符：</strong><br>%Y四位年份 %y两位年份 %m月 %H时 %i分 %s秒</p><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p><strong>if(条件,A,B)</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> 属性名</span><br><span class="line"><span class="keyword">when</span> 条件<span class="number">1</span> <span class="keyword">then</span> 语句<span class="number">1</span></span><br><span class="line"><span class="keyword">when</span> 条件<span class="number">1</span> <span class="keyword">then</span> 语句<span class="number">23</span></span><br><span class="line"><span class="keyword">when</span> 条件<span class="number">1</span> <span class="keyword">then</span> 语句<span class="number">3</span></span><br><span class="line"><span class="keyword">else</span> 语句<span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="分组函数"><a href="#分组函数" class="headerlink" title="分组函数"></a>分组函数</h3><p><strong>sum()</strong> 求和<br><strong>avg()</strong> 求平均<br>min()最小值 max()最大值 count()个数<br><strong>count(*)</strong> 返回行数，等效于count(常量)</p><h4 id="group-by"><a href="#group-by" class="headerlink" title="group by"></a>group by</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 查询列表,属性</span><br><span class="line"><span class="keyword">from</span> 表名</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> 属性;</span><br></pre></td></tr></table></figure><h4 id="having"><a href="#having" class="headerlink" title="having"></a>having</h4><p>二次筛选（分组后筛选）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>),属性</span><br><span class="line"><span class="keyword">from</span> 表名</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> 属性</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>)<span class="operator">&gt;</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure><h2 id="DML：数据操作语言"><a href="#DML：数据操作语言" class="headerlink" title="DML：数据操作语言"></a>DML：数据操作语言</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络个人向笔记</title>
      <link href="/2023/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%AA%E4%BA%BA%E5%90%91%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%AA%E4%BA%BA%E5%90%91%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络与互联网"><a href="#计算机网络与互联网" class="headerlink" title="计算机网络与互联网"></a>计算机网络与互联网</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本门课程章节：</p><ol><li><strong>计算机网络和互联网</strong>：绪论、关键术语和概念、框架性原理</li><li><strong>应用层</strong>：<ul><li>cs模型、p2p模型</li><li>DNS域名系统</li><li>电子邮件（SMTP, POP3, MIME）、FTP</li><li>万维网（HTTP）</li></ul></li><li><strong>传输层</strong>：<ul><li>UDP, TCP</li><li>套接字编程</li></ul></li><li><strong>网络层：数据平面</strong>：<ul><li>网络互联构造</li><li>路由算法</li></ul></li><li><strong>网络层：控制平面</strong>：<ul><li>ipv4, 寻址</li></ul></li><li><strong>数据链路网和局域网（物理层）</strong><ul><li>局域网、拓扑</li><li>帧</li><li>奇偶校验码</li><li>循环冗余码（CRC）</li><li>海明码</li><li>CSMA</li><li>PPP</li></ul></li><li><strong>网络安全</strong></li><li><strong>无线和移动网络</strong></li><li><strong>多媒体网络</strong></li><li><strong>网络管理</strong></li></ol><p><strong>计算机网络核心原理</strong>：自底向上，每一层都有功能，向上有接口，向上层提供服务。同时每一层的实现依赖下层接口。</p><h2 id="Internet"><a href="#Internet" class="headerlink" title="Internet"></a>Internet</h2><p><strong>网络</strong>：节点和边</p><p><strong>计算机网络</strong>：联网的计算机所构成的系统</p><p><strong>互联网</strong>：以TCP、IP协议为主构成的计算机网络</p><p>Internet：网络的网络</p><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p><strong>主机节点（端节点）</strong>：电脑、智能设备（数据源、数据目标）（host, end system）</p><p><strong>数据交换节点</strong>：路由器、交换机、中继器（不同层的）（数据中转站）</p><h3 id="边"><a href="#边" class="headerlink" title="边"></a>边</h3><p><strong>链路</strong>：光纤、电缆、无线电、卫星等</p><p><strong>带宽</strong>：传输速率，bps (bits per second)</p><p><strong>接入网链路</strong>：主机连接到互联网</p><p><strong>主干链路</strong>：路由器间</p><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>互联网信息传输的标准，使得不同厂商的设备实现互操作</p><p><strong>定义：对等层的实体，在通信的过程当中应该遵守的规则的集合</strong></p><p>定义了两个或多个通信实体之间交换的报文<strong>格式和次序</strong>，以及在报文传输接收等事件中所采取的<strong>动作</strong></p><p>例如：主机需要访问服务器，首先会发送一个tcp协议请求，当请求通过后，两者建立连接，采用tcp协议进行通信</p><h3 id="从服务角度"><a href="#从服务角度" class="headerlink" title="从服务角度"></a>从服务角度</h3><p><strong>互联网</strong>&#x3D;分布式应用进程+基础设施（向进程提供通信服务）</p><p>分布式的应用是互联网存在的原因，也是目的。</p><p>本机操作系统向应用进程提供的网络接口：socket api，使得应用进程可以和其他主机应用进程通讯</p><p>TCP：面向连接的服务</p><p>UDP：无连接的服务</p><h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><p><strong>网络边缘：主机（包含分布式的应用进程和协议）</strong>，也就是信息源，发出端，作用是支持其上的网络应用的通信</p><p><strong>网络核心：路由器和网络的网络</strong>，作用是连接所有的端系统，全球范围内的所有节点的数据交换</p><p><strong>网络接入：网络边缘接入到网络核心的链路</strong></p><p>除了应用进程之外其他的都算基础设施</p><h3 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h3><h4 id="网络通信模式"><a href="#网络通信模式" class="headerlink" title="网络通信模式"></a>网络通信模式</h4><p><strong>cs模式</strong>：client-server客户端服务器模式：服务器先启动，让客户端发送请求，请求服务器的软硬件资源<br>server farm 服务器农场<br>缺点：可扩展性较差，但请求数量到达阈值时断崖式下降</p><p><strong>P2P模式</strong>：peer to peer 向其他的客户端请求数据<br>例如迅雷，可以将一个文件拆成多个片段分别从不同的客户端下载，可以提高下载速度</p><h4 id="协议类型"><a href="#协议类型" class="headerlink" title="协议类型"></a>协议类型</h4><p>面向连接：先打招呼，确定连接，之后请求</p><p>非连接：直接请求</p><p>可靠的通讯：不丢失、不出错、不重复、不乱序</p><p>例如tcp的作用：下层不可靠，但需要为上层服务提供可靠的通讯，因此需要用时间和空间提升其通讯的可靠性<br>同时，tcp还会实现流量控制，确保从服务器发出的信息都能被处理<br>第三，tcp还会实现拥塞控制，检测网络核心的链路是否有堵塞，如果有，则控制其发送速率</p><p>udp则不同：无连接、不可靠、无流量控制、无拥塞控制</p><h3 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h3><p>网络核心数据交换模式：</p><h4 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h4><p>为每一个呼叫预留一条专有线路，例如电话线</p><p>每两台路由器之间的链路被分为多条<strong>片</strong>，呼叫时由信令系统在路径上每两台路由器之间选择一条，最终连成一条唯一的线路<br>分片方式有频分FDM（不同频率段），时分TDM（不同时间段），波分WDM（光纤不同波长）</p><p>每个呼叫只要建立起来就能够保证性能，但如果呼叫没有发送数据，则被分配的线路就会被浪费</p><blockquote><p><strong>时空图</strong>：AB两条竖直的平行线表示两台主机的时间，记得考虑接收时间延迟</p></blockquote><p><strong>电路交换不适合计算机之间通讯</strong>：</p><ol><li><p>连线建立时间长</p></li><li><p>计算机通信具有突发性，浪费的片较多</p></li></ol><h4 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h4><p>将要传输的数据分成一个个单位（<strong>分组</strong>），在传输时由路由器分别传输到可能不同的相邻的路由器，每个路由器经过存储、转发，最终合并</p><p>采用链路的最大的传输能力</p><p>采用存储转发的方式使得整条链路不同路由器之间的线路不是时时刻刻被占用，<strong>按需使用</strong><br>延迟较大，因为只有整个分组全部传达后才开始转发</p><p>如果到达速率大于输出速率：</p><ol><li><p>链路会排队等待传输</p></li><li><p>如果缓存用完了分组会被抛弃</p></li></ol><p><strong>关键功能</strong></p><ol><li><p><strong>路由</strong>：决定分组采用的源到目标的路径</p></li><li><p><strong>转发</strong>：路由器将分组从输入转移到输出链路，由 <strong>路由算法</strong>决定</p></li></ol><p><strong>统计多路复用</strong>：AB都作为数据源争夺链路，采用某种算法将链路按照时间分给AB（不是平均分）</p><p><strong>分组交换允许更多用户使用网络</strong>：<br>比如链路最多容纳10个用户，现在有35个用户，那么挤爆的概率是1 - sigma(n&#x3D;1 &#x2F; 9) ( Cn&#x2F;35 * P^n^ * (1-P)^(35-n)^ ) &#x3D; 0.004<br>同时，还有等待队列，因此不会爆</p><p><strong>分类</strong>：</p><ol><li><p><strong>数据报网络datagram</strong>：无连接，每个分组携带目标完整地址，由此决定下一跳的路由器，不同阶段可以改变路由，不需要维护主机间通信的状态<br>路径不一样，可能会失序<br>internet</p></li><li><p><strong>虚电路网络</strong>：有连接，主机通讯前先握手，建立虚拟线路，每个分组携带虚电路号<br>虚电路号仅标识两个路由器之间的链路，每次存储转发会变化<br>虚电路表存储源路由器名，源虚电路号，目标路由器名，目标虚电路号<br>x.25 和 ATM</p></li></ol><h3 id="网络接入"><a href="#网络接入" class="headerlink" title="网络接入"></a>网络接入</h3><p><strong>端系统和边缘路由器的连接</strong></p><p><strong>接入带宽</strong></p><p><strong>共享&#x2F;专用</strong></p><h4 id="接入方式"><a href="#接入方式" class="headerlink" title="接入方式"></a>接入方式</h4><ol><li><strong>（调制解调器modem（猫））</strong>在电话线发出端，modem将正弦波音频进行调频与调相位等操作，传递数据信息，用另一个modem解读<br>在<strong>音频载波信号上加载了上网的数据</strong>，因此叫“<strong>网上冲浪</strong>”</li><li><strong>（DSL）</strong>在电话线中，0-4kHz用于语音通信，4k以上用于传递数据信息，例如4-6k上行，6-10k下行（下行更大）</li><li><strong>（线缆网络）</strong>利用有线电视，将有线电缆数字化，但只有下行，上行依然需要modem（共享）</li><li>家庭、企业接入：区域内有线&#x2F;无线先接到路由器，再由路由器统一接到互联网</li><li><strong>（无线局域网WLAN）</strong></li><li><strong>（广域无线网）</strong>由电信运营商提供，通过基站、4G5G方式接入互联网</li></ol><p><strong>应用和网络相互促进</strong>：应用需要更高带宽更低延时促进网络发展，网络发展后又促进新应用产生</p><h4 id="物理媒体"><a href="#物理媒体" class="headerlink" title="物理媒体"></a>物理媒体</h4><p>相邻两个节点之间传输比特的线路</p><p>导引型媒介：光纤、电缆、电话线…</p><ul><li><p>双绞线：两根&#x2F;n根具备绝缘层的铜线拧合而成</p></li><li><p>同轴电缆：两根同心铜导线</p></li><li><p>光缆：光信号，很少受电磁波影响，误码率低（骨干链路几乎都是）</p></li></ul><p>非导引型媒介：电磁波、…</p><ul><li>卫星：同步轨道卫星，延迟很大（数百毫秒 ）</li><li>地面微波</li><li>无线网LAN</li><li>广域网：蜂窝移动网络</li></ul><h3 id="互联网结构"><a href="#互联网结构" class="headerlink" title="互联网结构"></a>互联网结构</h3><p><strong>互联网：网络的网络</strong></p><h4 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h4><p><strong>internet service provider 互联网业务提供商</strong>：移动、联通、电信</p><p>端系统通过接入ISP后再连接到互联网</p><p>global ISP：全球范围内接入ISP的ISP</p><h4 id="POP-x2F-IXP"><a href="#POP-x2F-IXP" class="headerlink" title="POP&#x2F;IXP"></a>POP&#x2F;IXP</h4><p>point of presence 负责高层ISP和低层ISP之间的互联</p><p>internet exchange point 负责ISP之间的数据互联</p><h4 id="ICP"><a href="#ICP" class="headerlink" title="ICP"></a>ICP</h4><p><strong>internet contence provider 互联网内容提供商</strong>：百度、谷歌</p><p>例如谷歌或腾讯，因为isp提供的服务价格高质量不稳定，采用在各地部署机房再利用局部isp去节约成本</p><h2 id="分组交换相关概念"><a href="#分组交换相关概念" class="headerlink" title="分组交换相关概念"></a>分组交换相关概念</h2><h3 id="一跳-x2F-一段（hop）"><a href="#一跳-x2F-一段（hop）" class="headerlink" title="一跳&#x2F;一段（hop）"></a>一跳&#x2F;一段（hop）</h3><p><strong>两个路由器之间的延时</strong></p><h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><p><strong>流量程度 I&#x3D;a×L&#x2F;R 单位时间内到达分组数量×分组大小&#x2F;带宽</strong></p><p>I&#x3D;0-1，期望排队时间呈指数增长，I&gt;1期望排队时间无穷大</p><h3 id="分组丢失"><a href="#分组丢失" class="headerlink" title="分组丢失"></a>分组丢失</h3><p>在路由器中，每条链路都对应相应队列，分组进入后通过查询路由表确定要从该链路传输后，如果链路中有分组还在传输，则新到达分组在队列中排队</p><p><strong>如果此时队列溢出，则分组丢失</strong></p><h3 id="分组延时"><a href="#分组延时" class="headerlink" title="分组延时"></a>分组延时</h3><ol><li><strong>处理延时</strong>：分组进入路由器后需要查询路由表排队等处理时间</li><li><strong>排队延时</strong>：在等待传输队列中的排队时间</li><li><strong>传输延时：</strong>分组全部发出（接收）的时间（分组大小&#x2F;带宽）</li><li><strong>传播延时</strong>：链路中传播的时间（物理链路长度&#x2F;速度）</li></ol><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><h3 id="CS模型"><a href="#CS模型" class="headerlink" title="CS模型"></a>CS模型</h3><p><strong>服务器、客户端</strong></p><p><strong>工作流程</strong>： 服务器处于接受请求状态 -  客户机发出请求，等待接受结果 - 服务器收到请求，进行分析和处理，得到结果返回客户机</p><p><strong>特点</strong>：客户机之间不直接通信，可扩展性较弱</p><p>例如：web， FTP</p><h3 id="P2P模型"><a href="#P2P模型" class="headerlink" title="P2P模型"></a>P2P模型</h3><p>peer to peer，没有特定的客户端和服务器之分，每个主机地位相等，直接通信，每个节点既作为客户也作为服务器。</p><p><strong>反对p2p</strong>：隐私性强、无法精确流量监控</p><p><strong>p2p损坏机械硬盘</strong>：分段传输、不连续，磁针需要经常反转急停</p><p><strong>网络拥塞</strong></p><h2 id="DNS系统"><a href="#DNS系统" class="headerlink" title="DNS系统"></a>DNS系统</h2><p><strong>Domain Name System，用于将域名转换成IP地址</strong></p><p><em>域名和URL的区别：域名+ip地址&#x3D;URL</em></p><p>运行在UDP上，用53号端口</p><p>英文不区分大小写，只能使用连字符“-”，每个符号不超过63字符，总长度不超过255字符，从左到右级别从低到高</p><h3 id="域名分类"><a href="#域名分类" class="headerlink" title="域名分类"></a>域名分类</h3><p>根域名服务器：最高层次，用于存储顶级域名服务器ip</p><p>顶级域名服务器（TLD服务器）：国家nTLD（.cn, .hk），通用gTLD（.com, .net, .top），返回</p><p>权威域名服务器：返回ip，例如baidu, google</p><p><strong>迭代查询</strong>：本地依次查询根域名、TLD域名、权威域名服务器</p><p><strong>递归查询</strong>：本地查询根域名，根域名查询TLD域名、TLD域名查询权威域名，逐级返回</p><p>DNS服务器有缓存，但在一段时间后丢弃</p><h2 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h2><p><strong>用户代理UA</strong>：向用户的接口（客户端）</p><h3 id="邮件服务器"><a href="#邮件服务器" class="headerlink" title="邮件服务器"></a>邮件服务器</h3><p><strong>SMTP协议</strong>：邮件发送协议，用户代理向服务器发送邮件或服务器间发送</p><p><strong>POP3</strong>：邮件读取协议，用户代理从邮件服务器读取邮件</p><p><strong>MIME</strong>：可传输二进制对象、多媒体等</p><h2 id="WWW"><a href="#WWW" class="headerlink" title="WWW"></a>WWW</h2><p><strong>World Wide Web，万维网</strong></p><p><strong>统一资源定位符URL</strong>：文档的唯一标识</p><p><strong>超文本传输协议HTTP</strong>：应用层协议，使用TCP进行可靠传输</p><p><strong>超文本标记语言HTML</strong>：对页面上的信息进行标记</p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>每个站点有一个服务器进程，默认端口80</p><p>状态码：1XX，2XX表示成功，3XX表示重定向，4XX客户端前端问题，5XX后端数据库问题</p><p>持久连接：服务器在发送响应后仍然保持这条连接，使每个用户和服务器可以继续在这条连接上传送 后续的HTTP请求与响应报文</p><p>​非流水线：客户收到前一个响应才发出下一个请求</p><p>​流水线：客户每遇到一个对象发出一个请求</p><p>非持久连接：每个网页元素（如JPEG图形，Flash等）的传输 都需要单独建立一个TCP连接</p><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="传输层协议"><a href="#传输层协议" class="headerlink" title="传输层协议"></a>传输层协议</h2><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p><strong>客户端与服务器端口间通信</strong></p><p><strong>报文首部内容：</strong></p><ol><li>源端口、目的端口，各自占4字节</li><li>序号<strong>seq</strong>（<strong>起始序号</strong>）：4字节，本段报文的起始序号，<strong>TCP字段中每个字节有一个序号，按顺序</strong></li><li>确认号<strong>ack</strong>（<strong>截止序号+1</strong>）：4字节，报文全部收到后，下一个报文的起始序号</li><li>数据偏移：4位，报文数据与报文段的距离，即首部长度</li><li>保留，6位，均为0</li><li>紧急URG：当URG&#x3D;1时，紧急字段有效表示紧急信息</li><li><strong>确认ACK，当ACK&#x3D;1时，字段有效</strong></li><li>推送PSH，一方键入后能立即收到对方响应</li><li>复位RST，要求释放连接并重新建立</li><li>同步SYN，<strong>SYN&#x3D;1, ACK&#x3D;0为请求连接报文，SYN&#x3D;1, ACK&#x3D;1为同意连接报文</strong></li><li>终止FIN，<strong>FIN&#x3D;1要求释放连接</strong></li><li>窗口：2字节，发送方告诉接收方的需要预留空间</li><li>检验和：2字节，校验首部和数据两部分</li><li>紧急指针：2字节，紧急数据字节数</li></ol><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>（服务器处于LISTEN（监听）状态）</p><ol><li>客户端：你好（<strong>SYN&#x3D;1</strong>），我要给你我这边序号x的报文（<strong>seq&#x3D;x</strong>）</li></ol><p><em>（客户端进程进入了 SYN-SENT（同步已发送状态）状态）</em></p><ol start="2"><li>服务器：你好（<strong>SYN&#x3D;1</strong>），我能收到你（<strong>ACK&#x3D;1</strong>），我要给你我这边y的信息（<strong>seq&#x3D;y</strong>），我期待收到你那边序号x+1的报文（<strong>ack&#x3D;x+1</strong>）</li></ol><p><em>（进入了SYN-RCVD（同步收到）状态）</em></p><ol start="3"><li>客户端：好的，我能收到你（<strong>ACK&#x3D;1</strong>），我继续给你我这边序号x+1的报文（<strong>seq&#x3D;x+1</strong>），并且期待收到你那边序号y+1的报文（<strong>ack&#x3D;y+1</strong>）</li></ol><p><em>（双方进入了ESTABLISHED（已建立连接）状态）</em></p><p>![image-20230223161955975](E:\Program Files (x86)\typora\images\计算机网络\image-20230223161955975.png)</p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><ol><li><p>客户端：我已经发送完我所有信息了，拜拜（<strong>FIN&#x3D;1</strong>），这条报文是为了和你告别的（<strong>seq&#x3D;u</strong>）</p><p><em>（客户端进入了 FIN-WAIT-1（终止等待1）状态）</em></p></li><li><p>服务器：好的收到（<strong>ACK&#x3D;1</strong>），我也将发送我的最后信息（<strong>seq&#x3D;v</strong>），期待收到你的最后报文（<strong>ack&#x3D;u+1</strong>）</p><p><em>（进入CLOSE-WAIT（关闭等待）状态，服务器无法再接收到客户端的消息，但依然发送消息）</em></p><p><em>（客户端收到后进入了（FIN-WAIT-2（终止等待2）状态））</em></p><p>服务器发送报文中……</p></li><li><p>服务器：好了，我已经发送完我所有信息了（<strong>ACK&#x3D;1</strong>），咱们可以结束了（<strong>FIN&#x3D;1</strong>），这是我的最后报文（<strong>seq&#x3D;w</strong>），期待收到你的最后报文（<strong>ack&#x3D;u+1</strong>），再见！</p><p><em>（服务器进入了LAST-ACK（最后确认）状态）</em></p></li><li><p>客户端：收到了（<strong>ACK&#x3D;1</strong>），收到你最后报文了（<strong>ack&#x3D;w+1</strong>），这是我的最后报文（<strong>seq&#x3D;u+1</strong>），再见！<br><em>（进入TIME-WAIT（时间等待）状态，此时TCP连接还没有释放，必须经过 2 MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。）</em></p><p><em>（服务器收到后进入CLOSED状态）</em></p></li></ol><p>![image-20230223163448163](E:\Program Files (x86)\typora\images\计算机网络\image-20230223163448163.png)</p><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="路由系统"><a href="#路由系统" class="headerlink" title="路由系统"></a>路由系统</h2><ul><li><strong>转发forwarding</strong>是指将分组从一个输入链路接口移动到适当的输出链路接口的路由器本地动作。时间尺度很短，通常为几纳秒。</li><li><strong>路由选择routing</strong>是指确定分组从源到目的地所采取的端到端路径的网络范围处理过程，时间尺度较长，通常为几秒。</li></ul><p><strong>转发表</strong>：字段索引，转发分组</p><ul><li>传统方式：路由选择算法在路由器间进行转发，通过路由选择协议将路由选择信息报文放入转发表</li><li>SDN方式，远程控制器计算分发给每个路由器使用</li></ul><h2 id="SDN"><a href="#SDN" class="headerlink" title="SDN"></a>SDN</h2><p>软件定义网络，对路由器采用集中控制，远程控制</p><p>具有很好的可编程性，SDN系统北向编程接口，南向控制接口等</p><p>集中高效管理，提高性能降低成本，不过</p><h3 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h3><p><strong>静态路由算法：</strong>手工配置</p><h2 id="ipv4"><a href="#ipv4" class="headerlink" title="ipv4"></a>ipv4</h2><h3 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h3><p>![image-20230223211120092](E:\Program Files (x86)\typora\images\计算机网络\image-20230223211120092.png)</p><p><strong>广播地址：将后面0的部分都变成1</strong></p><p>其中&#x2F;18是子网长度（<strong>CIDR协议</strong>）</p><h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><p>DHCP服务器（路由器）给下属的主机分配ip</p><p>主机发discover-&gt;DHCP回复offer -&gt; 主机问request -&gt;DHCP回ack</p><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><h2 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h2><h2 id="可靠传输协议"><a href="#可靠传输协议" class="headerlink" title="可靠传输协议"></a>可靠传输协议</h2><h3 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h3><p><strong>一帧一帧发送，收到ACK后才能发送下一帧</strong></p><p>发送方装备<strong>计时器</strong>，如果一定时间内未收到接收方的确认帧（ACK），则再次发送相同的数据帧。</p><p>在接收方收到重复数据帧时，丢弃，并且重新发送确认帧（ACK）</p><h3 id="GBN"><a href="#GBN" class="headerlink" title="GBN"></a>GBN</h3><p>发送方发送窗口：将几个帧归为一组，一次性发送之后等待</p><p>接收方：从小编号开始逐个接收，接收到大编号的帧，如果其之前未得到确认，则丢弃。</p><p>发送方，当收到一个确认帧时，得知该帧和之前所有帧都发送成功了，发送窗口后移。</p><h3 id="SR"><a href="#SR" class="headerlink" title="SR"></a>SR</h3><p>发送方发送窗口不变，不过需要逐帧确认。</p><p>接收方有一个缓冲区，接收到大编号的帧，如果其之前未得到确认，则进入缓冲区返回ACK。直到接收窗口边缘或者缓冲区满。</p><p>接收到小编号帧时，从缓冲区找大编号帧。</p><p>收到一个错误帧，返回NAK，要求发送方重传。</p><h2 id="循环冗余码CRC"><a href="#循环冗余码CRC" class="headerlink" title="循环冗余码CRC"></a>循环冗余码CRC</h2><p>![image-20230223223604163](E:\Program Files (x86)\typora\images\计算机网络\image-20230223223604163.png)</p><h2 id="CSMA"><a href="#CSMA" class="headerlink" title="CSMA"></a>CSMA</h2><h3 id="ALOHA"><a href="#ALOHA" class="headerlink" title="ALOHA"></a>ALOHA</h3><p>不监听，想发就发，一段时间内未收到确认就重发</p><h3 id="时隙ALOHA"><a href="#时隙ALOHA" class="headerlink" title="时隙ALOHA"></a>时隙ALOHA</h3><p>分时间片，多个端口想要占用信道，在时间片开始想用就用</p><h3 id="1-坚持-CSMA"><a href="#1-坚持-CSMA" class="headerlink" title="1-坚持 CSMA"></a>1-坚持 CSMA</h3><p>坚持监听，有空隙就发送，不过可能几个同时发送，会冲突</p><h3 id="非坚持CSMA"><a href="#非坚持CSMA" class="headerlink" title="非坚持CSMA"></a>非坚持CSMA</h3><p>隔一段时间监听一次，有空隙就发送</p><h3 id="P-坚持CSMA"><a href="#P-坚持CSMA" class="headerlink" title="P-坚持CSMA"></a>P-坚持CSMA</h3><p>一直监听，有空隙则有概率P发送，否则到下一个时间片监听</p><h3 id="CSMA-x2F-CD"><a href="#CSMA-x2F-CD" class="headerlink" title="CSMA&#x2F;CD"></a>CSMA&#x2F;CD</h3><p>以太网协议，一直监听，有空闲就发，产生冲突时比较二进制指数（逐位比大小）</p><p>边发送边侦听，一旦出现碰撞马上停止发送，等待一段时间重新监听</p><h3 id="CSMA-x2F-CA"><a href="#CSMA-x2F-CA" class="headerlink" title="CSMA&#x2F;CA"></a>CSMA&#x2F;CA</h3><p>一直监听，有空闲就发RTS（预约）</p><p>收到CTS（预约成功，监听后发送），发送帧，每次等待ACK</p><h2 id="PPP"><a href="#PPP" class="headerlink" title="PPP"></a><strong>PPP</strong></h2><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java常用API个人向总结</title>
      <link href="/2023/03/21/Java%E5%B8%B8%E7%94%A8API%E4%B8%AA%E4%BA%BA%E5%90%91%E6%80%BB%E7%BB%93/"/>
      <url>/2023/03/21/Java%E5%B8%B8%E7%94%A8API%E4%B8%AA%E4%BA%BA%E5%90%91%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">outer:</span><br><span class="line"><span class="keyword">for</span>()&#123;</span><br><span class="line">  <span class="keyword">break</span> outer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">out.println(<span class="string">&quot;\&quot;Hello\&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="Math-x2F-类型转换"><a href="#Math-x2F-类型转换" class="headerlink" title="Math&#x2F;类型转换"></a>Math&#x2F;类型转换</h2><p><strong>类型转换</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">int</span>)c</span><br></pre></td></tr></table></figure><p><strong>经典四舍五入</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">data</span> <span class="operator">=</span> <span class="number">3.02</span>;</span><br><span class="line"><span class="comment">//利用字符串格式化的方式实现四舍五入,保留1位小数</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> String.format(<span class="string">&quot;%.1f&quot;</span>,data);</span><br><span class="line"><span class="comment">//1代表小数点后面的位数, 不足补0。f代表数据是浮点类型。保留2位小数就是“%.2f”，依此累推。</span></span><br><span class="line">System.out.println(result);<span class="comment">//输出3.0</span></span><br></pre></td></tr></table></figure><p><strong>double四舍五入转换成long</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> b=Math.round(<span class="type">double</span> a);</span><br></pre></td></tr></table></figure><p><strong>向上&#x2F;向下取整</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> Math.ceil(<span class="type">double</span> d);<span class="comment">//向上取整</span></span><br><span class="line"><span class="type">int</span> Math.floor(<span class="type">double</span> d);<span class="comment">//向下取整</span></span><br></pre></td></tr></table></figure><p><strong>保留小数位数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(String.formate(<span class="string">&quot;%.1f&quot;</span>,d));<span class="comment">//四舍五入保留一位小数</span></span><br><span class="line">System.out.println(<span class="string">&quot;%.1f&quot;</span>,d);</span><br></pre></td></tr></table></figure><p><strong>进制转换</strong></p><p>r进制转10进制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> Integer.parseInt(String str,<span class="type">int</span> r);</span><br></pre></td></tr></table></figure><p>10进制转2&#x2F;8&#x2F;16进制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str=Integer.toBinaryString(n);</span><br><span class="line">Integer.toOctalString(n);</span><br><span class="line">Integer.toHexString(n));</span><br></pre></td></tr></table></figure><h2 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h2><h2 id="BigInterger"><a href="#BigInterger" class="headerlink" title="BigInterger"></a>BigInterger</h2><p>大数，理论无限大</p><p><strong>定义：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BigInterger a=sc.nextBigInterger();</span><br><span class="line"></span><br><span class="line">String s=<span class="string">&quot;100000&quot;</span>;</span><br><span class="line">BigInterger b=<span class="keyword">new</span> <span class="title class_">BigInterger</span>(s);</span><br><span class="line"><span class="comment">//非十进制的字符串</span></span><br><span class="line">BigInterger b=<span class="keyword">new</span> <span class="title class_">BigInterger</span>(s,radix);</span><br><span class="line"><span class="comment">//int转bigInterger</span></span><br><span class="line"><span class="type">int</span> i=<span class="number">10</span>;</span><br><span class="line">BigInterger c=BigInterger.valueOf(i);</span><br></pre></td></tr></table></figure><p><strong>运算</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c=a.add(b);<span class="comment">//a+b</span></span><br><span class="line">c=a.substract(b);<span class="comment">//a-b</span></span><br><span class="line">c=a.multiply(b);<span class="comment">//a*b</span></span><br><span class="line">c=a.divide(b);<span class="comment">//a/b</span></span><br><span class="line">c=a.mod(b);<span class="comment">//a%b</span></span><br><span class="line">a.compareTo(b);<span class="comment">//1大于0等于-1小于</span></span><br></pre></td></tr></table></figure><p><strong>类型转换：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s=a.toString();</span><br><span class="line"><span class="comment">//转换成非十进制字符串</span></span><br><span class="line">String s=a.toString(radix);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i=a.intValue();</span><br><span class="line"><span class="type">double</span> d=a.doubleValue();</span><br></pre></td></tr></table></figure><h2 id="Date-x2F-SimpleDateFormate"><a href="#Date-x2F-SimpleDateFormate" class="headerlink" title="Date&#x2F;SimpleDateFormate"></a>Date&#x2F;SimpleDateFormate</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);<span class="comment">//年-月-日</span></span><br><span class="line">Date today=sdf.parse(String todayStr);</span><br><span class="line">Date tomorrow=<span class="keyword">new</span> <span class="title class_">Date</span>(today.getTime()+<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">1000</span>)；<span class="comment">//毫秒</span></span><br></pre></td></tr></table></figure><h1 id="一维容器"><a href="#一维容器" class="headerlink" title="一维容器"></a>一维容器</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span>[] array=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] array=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复制数组</span></span><br><span class="line"><span class="type">int</span>[] arrB = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">6</span>];</span><br><span class="line">System.arraycopy(arr, <span class="number">0</span>, arrB, <span class="number">0</span>, arr.length);</span><br><span class="line"><span class="type">int</span>[] arrC = Arrays.copyOf(arr, arr.length);</span><br></pre></td></tr></table></figure><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] array=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>][<span class="number">5</span>];</span><br></pre></td></tr></table></figure><h2 id="Collections-集合"><a href="#Collections-集合" class="headerlink" title="Collections 集合"></a>Collections 集合</h2><h3 id="ArrayList-集合"><a href="#ArrayList-集合" class="headerlink" title="ArrayList 集合"></a>ArrayList 集合</h3><p>一个大小可变的数组，且允许null元素、可以自动增长<br>比普通数组慢一些，但支持灵活插入与删除元素</p><p>Vector同一时间允许一个线程进行访问，效率较低，但是不会发生并发错误。</p><p>ArrayList同一时间允许多个线程进行访问，效率高，但是可能会发生并发错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="keyword">public</span> ArrayList&lt;String&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> ArrayList&lt;String&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(oldList);</span><br><span class="line"><span class="comment">//通用</span></span><br><span class="line">list.size();</span><br><span class="line">list.clear();</span><br><span class="line">list.contains(<span class="string">&quot;element&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取元素</span></span><br><span class="line">list.get(index);</span><br><span class="line"><span class="comment">//添加元素</span></span><br><span class="line">list.add(<span class="string">&quot;element&quot;</span>);</span><br><span class="line">list.add(index,<span class="string">&quot;element&quot;</span>);<span class="comment">//特定位置插入</span></span><br><span class="line">Collections.addAll(list,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>);<span class="comment">//依次添加多个</span></span><br><span class="line">Collections.addAll(list,array);<span class="comment">//用于数组转集合</span></span><br><span class="line">list.addAll(listB);</span><br><span class="line"><span class="comment">//删除元素</span></span><br><span class="line">list.remove(index);</span><br><span class="line">list.remove(<span class="string">&quot;element&quot;</span>);</span><br><span class="line"><span class="comment">//注意，对于LinkedList&lt;Integer&gt;，remove(object)如下：</span></span><br><span class="line">list.remove((Integer)element);</span><br><span class="line">list.remove(listB);</span><br><span class="line"><span class="comment">//修改元素</span></span><br><span class="line">list.set(<span class="number">0</span>,<span class="string">&quot;element&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找元素</span></span><br><span class="line">list.indexOf(<span class="string">&quot;element&quot;</span>);</span><br><span class="line"><span class="comment">//子链表，注意只返回list</span></span><br><span class="line">List&lt;String&gt; listB = list.subList(start,end);</span><br><span class="line"><span class="comment">//集合转数组</span></span><br><span class="line">String[] array =list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">  System.out.println(list.get(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//foreach</span></span><br><span class="line"><span class="keyword">for</span>(String string:list)&#123;</span><br><span class="line">  System.out.println(string);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代器</span></span><br><span class="line"><span class="keyword">for</span>(Iterator&lt;String&gt; iter=list.iterator();iter.hasNext();)&#123;</span><br><span class="line">    System.out.println(iter.next());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 在使用迭代器时不允许增删</span></span><br><span class="line"><span class="comment"> * iter.remove(); 迭代器删除</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="LinkedList-链表"><a href="#LinkedList-链表" class="headerlink" title="LinkedList 链表"></a>LinkedList 链表</h3><p>相比ArrayList，添加删除更快，查找遍历更慢</p><p><strong>注意，LinkList用for循环遍历特别慢，可以用迭代器或者转数组读</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line">LinkedList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//其余同ArrayList，只写不一样的</span></span><br><span class="line"><span class="comment">//添加首尾元素</span></span><br><span class="line">list.addFirst(<span class="string">&quot;element&quot;</span>);</span><br><span class="line">list.addLast(<span class="string">&quot;element&quot;</span>);</span><br><span class="line"><span class="comment">//删除首尾元素</span></span><br><span class="line">list.removeFirst();</span><br><span class="line">list.removeLast();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Stack-栈"><a href="#Stack-栈" class="headerlink" title="Stack 栈"></a>Stack 栈</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line">Stack&lt;String&gt; stack=<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//其余同ArrayList，只写不一样的</span></span><br><span class="line"><span class="comment">//压栈</span></span><br><span class="line">stack.push(<span class="string">&quot;element&quot;</span>);</span><br><span class="line"><span class="comment">//弹栈</span></span><br><span class="line">stack.pop();</span><br><span class="line"><span class="comment">//获取栈顶</span></span><br><span class="line">stack.peek();</span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line">stack.search(<span class="string">&quot;element&quot;</span>);<span class="comment">//等效于indexOf()</span></span><br></pre></td></tr></table></figure><h2 id="Queue-队列"><a href="#Queue-队列" class="headerlink" title="Queue 队列"></a>Queue 队列</h2><p><strong>先进先出</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line">Queue&lt;String&gt; queue=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();<span class="comment">//注意是LinkList构造出来的</span></span><br><span class="line"><span class="comment">//通用</span></span><br><span class="line">queue.size();</span><br><span class="line">queue.isEmpty();</span><br><span class="line">queue.contains(<span class="string">&quot;element&quot;</span>);</span><br><span class="line">queue.clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队（到队尾）</span></span><br><span class="line">queue.add(<span class="string">&#x27;element&#x27;</span>);<span class="comment">//队列满抛异常</span></span><br><span class="line">queue.offer(<span class="string">&#x27;element&#x27;</span>);<span class="comment">//返回true，队列满返回false</span></span><br><span class="line">queue.put(<span class="string">&#x27;element&#x27;</span>);<span class="comment">//队列满阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//出队（从对头）</span></span><br><span class="line">queue.remove();<span class="comment">//队列空抛异常</span></span><br><span class="line">queue.poll();<span class="comment">//队列空返回null</span></span><br><span class="line">queue.take();<span class="comment">//队列空阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查看头部元素</span></span><br><span class="line">queue.element();<span class="comment">//队列空抛异常</span></span><br><span class="line">queue.peek();<span class="comment">//队列空返回null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">for</span>(String string:queue)&#123;</span><br><span class="line">  System.out.println(string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PriorityQueue-优先队列"><a href="#PriorityQueue-优先队列" class="headerlink" title="PriorityQueue 优先队列"></a>PriorityQueue 优先队列</h3><p>通过完全二叉树（complete binary tree）实现的小顶堆（任意一个非叶子节点的权值，都不大于其左右子节点的权值）</p><p><strong>优先队列的作用是能保证每次取出的元素都是队列中权值最小的</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line">PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//其余和queue相同</span></span><br></pre></td></tr></table></figure><h3 id="ArrayDeque-双端队列"><a href="#ArrayDeque-双端队列" class="headerlink" title="ArrayDeque 双端队列"></a>ArrayDeque 双端队列</h3><p>速度比LinkedList快</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line">ArrayDeque&lt;String&gt; deque=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;String&gt;();</span><br><span class="line"><span class="comment">//其余和Queue一样，只写不一样的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//两头入队</span></span><br><span class="line">deque.addFirst(<span class="string">&#x27;element&#x27;</span>);<span class="comment">//队列满抛异常</span></span><br><span class="line">deque.addLast(<span class="string">&#x27;element&#x27;</span>);</span><br><span class="line">deque.offerFirst(<span class="string">&#x27;element&#x27;</span>);<span class="comment">//返回true，队列满返回false</span></span><br><span class="line">deque.offerLast(<span class="string">&#x27;element&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//两头出队</span></span><br><span class="line">queue.removeFirst();<span class="comment">//队列空抛异常</span></span><br><span class="line">queue.removeLast();</span><br><span class="line">queue.pollFirst();<span class="comment">//队列空返回null</span></span><br><span class="line">queue.pollLast();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Map-映射"><a href="#Map-映射" class="headerlink" title="Map 映射"></a>Map 映射</h2><h3 id="HashMap-哈希表（哈希映射）"><a href="#HashMap-哈希表（哈希映射）" class="headerlink" title="HashMap 哈希表（哈希映射）"></a>HashMap 哈希表（哈希映射）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line">HashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//通用</span></span><br><span class="line">map.size();</span><br><span class="line">map.isEmpty();</span><br><span class="line">map.clear();</span><br><span class="line"><span class="comment">//存放</span></span><br><span class="line"><span class="comment">//修改</span></span><br><span class="line">map.put(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);<span class="comment">//如果key已存在就修改</span></span><br><span class="line"><span class="comment">//获取</span></span><br><span class="line">map.get(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">map.getOrDefault(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;defaultValue&quot;</span>);<span class="comment">//没有则返回默认值</span></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">map.remove(<span class="string">&quot;key&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历对 (返回set)</span></span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String,String&gt; entry:map.entrySet())&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;Key = &quot;</span> + entry.getKey() + <span class="string">&quot;, Value = &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历key (返回set)</span></span><br><span class="line"><span class="keyword">for</span>(String key:map.keySet())&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;Key = &quot;</span> + key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历value (返回set)</span></span><br><span class="line"><span class="keyword">for</span>(String value:map.values())&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;Value = &quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="TreeMap-树表"><a href="#TreeMap-树表" class="headerlink" title="TreeMap 树表"></a>TreeMap 树表</h3><p>自带顺序，根据<strong>key</strong>排序的键值对，因此 <strong>key</strong>必须可以比较</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line">TreeMap&lt;Integer,String&gt; map=<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">TreeMap&lt;Integer,String&gt; map=<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;((Comparator.naturalOrder());<span class="comment">//同上，默认正序</span></span><br><span class="line">TreeMap&lt;Integer,String&gt; map=<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(Comparator.reverseOrder()); <span class="comment">//倒序</span></span><br><span class="line"><span class="comment">//新增</span></span><br><span class="line">map.put(key,<span class="string">&quot;value&quot;</span>);</span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">map.remove(key);</span><br><span class="line"><span class="comment">//修改</span></span><br><span class="line">map.replace(key,<span class="string">&quot;value&quot;</span>);</span><br><span class="line">map.replace(key,<span class="string">&quot;value&quot;</span>);</span><br><span class="line"><span class="comment">//获取</span></span><br><span class="line">map.get(key)</span><br><span class="line">map.containsKey(key);</span><br><span class="line">map.containdValue(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">map.firstKey();<span class="comment">//第一个（默认最小）key</span></span><br><span class="line">map.lastKay();<span class="comment">//最后一个（默认最大）key</span></span><br><span class="line">map.firstEntry();<span class="comment">//第一个键值对</span></span><br><span class="line">map.lastEntry();<span class="comment">//最后一个键值对</span></span><br><span class="line"><span class="comment">//其余同HashMap</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set 集合"></a>Set 集合</h2><h3 id="HashSet-哈希集"><a href="#HashSet-哈希集" class="headerlink" title="HashSet 哈希集"></a>HashSet 哈希集</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//通用</span></span><br><span class="line">set.size();</span><br><span class="line">set.isEmpty();</span><br><span class="line">set.clear();</span><br><span class="line">set.contains(<span class="string">&quot;element&quot;</span>);</span><br><span class="line"><span class="comment">//添加元素</span></span><br><span class="line">set.add(<span class="string">&quot;element&quot;</span>);</span><br><span class="line">Collections.addAll(set,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>);<span class="comment">//依次添加多个</span></span><br><span class="line">Collections.addAll(set,strArr);<span class="comment">//数组转set</span></span><br><span class="line">Collections.addAll(set,setB);<span class="comment">//添加另一个set</span></span><br><span class="line"><span class="comment">//删除元素</span></span><br><span class="line">set.remove(<span class="string">&quot;element&quot;</span>);</span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">for</span>(String str:set)&#123;</span><br><span class="line">  System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TreeSet-树集"><a href="#TreeSet-树集" class="headerlink" title="TreeSet 树集"></a>TreeSet 树集</h3><p>HashSet底层使用的是HashMap结构储存,而TreeSet底层用的是TreeMap树结构储存。</p><p>因此TreeSet自带顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line">Set&lt;String&gt; set=<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">Set&lt;String&gt; set=<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(Comparator.naturalOrder());<span class="comment">//同上，默认正序</span></span><br><span class="line">Set&lt;String&gt; set=<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(Comparator.reverseOrder());<span class="comment">//倒序</span></span><br><span class="line"><span class="comment">//其余同HashSet</span></span><br></pre></td></tr></table></figure><h2 id="String-x2F-StringBuffer-字符串"><a href="#String-x2F-StringBuffer-字符串" class="headerlink" title="String&#x2F;StringBuffer 字符串"></a>String&#x2F;StringBuffer 字符串</h2><p>在java中，String类不可变，每次操作都会生成一个新的String<br>StringBuffer是一个可变类，任何操作都不会产生新的对象，利用多线程操作字符串但速度较慢<br>StringBuilder和StringBuffer类似，也可变且速度更快，但利用单线程导致线程不安全（不能同步访问）</p><p><strong>对于String</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取长度：</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//根据位置获取字符：</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">charAt</span><span class="params">(<span class="type">int</span> index)</span>;</span><br></pre></td></tr></table></figure><p>构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String(<span class="type">char</span>[] chs);</span><br><span class="line">String(<span class="type">char</span>[] chs,<span class="type">int</span> begin,<span class="type">int</span> count);<span class="comment">//从begin以后count个</span></span><br></pre></td></tr></table></figure><p>搜索：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(<span class="type">char</span> ch)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(String str1)</span>;<span class="comment">//第一次出现位置，否则返回-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(<span class="type">char</span> ch ,<span class="type">int</span> index)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(String str1 ,<span class="type">int</span> index)</span>;<span class="comment">//index后第一次出现位置，否则返回-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(<span class="type">char</span> ch)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(String str1)</span>;<span class="comment">//最后一次出现位置</span></span><br></pre></td></tr></table></figure><p>判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(String str1)</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">equalsIgnoreCase</span><span class="params">(String str1)</span>;<span class="comment">//忽略大小写判断相等</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(String str1)</span>;<span class="comment">//是否包含</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">startWith</span><span class="params">(String str1)</span>;<span class="comment">//是否为开头</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">endsWith</span><span class="params">(String str1)</span>;<span class="comment">//是否为结尾</span></span><br></pre></td></tr></table></figure><p>转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] toCharArray();<span class="comment">//转换为字符数组</span></span><br></pre></td></tr></table></figure><p>其他：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">toString</span><span class="params">()</span>;<span class="comment">//Object类方法，记录类名和位置</span></span><br><span class="line">String <span class="title function_">valueOf</span><span class="params">()</span>;<span class="comment">//同上，但不会报空指针而是显示null</span></span><br><span class="line">String <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> begin,<span class="type">int</span> count)</span>;<span class="comment">//从begin以后count个</span></span><br></pre></td></tr></table></figure><p><strong><code>valueOf</code>方法可以直接把基础数据类型转换成字符串</strong></p><p>操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">repleace</span><span class="params">(<span class="type">char</span> oldChar,<span class="type">char</span> newChar)</span>;<span class="comment">//注意返回值是String</span></span><br><span class="line">String <span class="title function_">replace</span><span class="params">(String oldStr,String oldStr)</span>;<span class="comment">//将所有oldStr替换成newStr</span></span><br><span class="line">String[] split(String s);<span class="comment">//按照某一字符串分割原字符串</span></span><br><span class="line">String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> begin,<span class="type">int</span> end)</span>;<span class="comment">//提取从begin到end的子串</span></span><br></pre></td></tr></table></figure><p><strong>对于StringBuffer&#x2F;StringBuilder</strong><br>操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">()</span>;<span class="comment">//翻转</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">append</span><span class="params">(Object obj)</span>;<span class="comment">//加在末尾</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> index,Object obj)</span><span class="comment">//插入</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> begin,<span class="type">int</span> end)</span>;<span class="comment">//删除</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">deleteCharAt</span><span class="params">(<span class="type">int</span> index)</span>;<span class="comment">//删除某一位</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">replace</span><span class="params">(<span class="type">int</span> begin,<span class="type">int</span> end,String str)</span>;<span class="comment">//替换</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setCharAt</span><span class="params">(<span class="type">int</span> index,<span class="type">char</span> ch)</span>;<span class="comment">//设置某一位</span></span><br></pre></td></tr></table></figure><p>判断：<br><strong>StringBuffer中 <code>equals()</code>方法未被重写，比较的是地址而不是内容</strong>，所以比较两个StringBuffer时需要调用两次<code>toString()</code>方法<br><strong>其余方法StringBuffer中未定义</strong></p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="Comparable接口"><a href="#Comparable接口" class="headerlink" title="Comparable接口"></a>Comparable接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt;&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.score=s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student o)</span> &#123;<span class="comment">//从小到大</span></span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">this</span>.score&gt;o.score)?<span class="number">1</span>:-<span class="number">1</span>;</span><br><span class="line"><span class="comment">//return this.score-o.score;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">Student[] arr=<span class="keyword">new</span> <span class="title class_">Student</span>[<span class="number">5</span>];</span><br><span class="line">Arrays.sort(arr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Comparator接口"><a href="#Comparator接口" class="headerlink" title="Comparator接口"></a>Comparator接口</h3><p><strong>单次排序可以直接在的调用方法时实现接口</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> score;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">Student[] a=<span class="keyword">new</span> <span class="title class_">Student</span>[<span class="number">10</span>];</span><br><span class="line">Arrays.sort(a, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> o1.score-o2.score;<span class="comment">//从小到大</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>多次排序可以创建一个对象以实现接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Student&gt; scoreCmp=<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> o1.score-o2.score;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Arrays.sort(a, scoreCmp);</span><br></pre></td></tr></table></figure><p><strong>也可以直接写一个类用于实现接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentSort</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Student&gt;&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;<span class="comment">//从小到大</span></span><br><span class="line"><span class="keyword">return</span> (o1.score&gt;o2.score)?<span class="number">1</span>:-<span class="number">1</span>;</span><br><span class="line"><span class="comment">//return o1.score-o2.score;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">Comparator cmp=<span class="keyword">new</span> <span class="title class_">StudentSort</span>();</span><br><span class="line">Student[] arr=<span class="keyword">new</span> <span class="title class_">Student</span>[<span class="number">5</span>];</span><br><span class="line">Arrays.sort(arr,cmp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>除此之外该接口还可以用于分组</strong></p><h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><p><strong>idea以ctrl+D结束输入</strong></p><h2 id="BufferedReader"><a href="#BufferedReader" class="headerlink" title="BufferedReader"></a>BufferedReader</h2><p>缓存读取类，加快输入速度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法 </span></span><br><span class="line">BufferedReader in=<span class="keyword">new</span> <span class="title class_">BufferedReader</span>( </span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line"><span class="comment">//读一行</span></span><br><span class="line">String[] strs = in.readLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="comment">//判断结束</span></span><br><span class="line">str=in.readLine();</span><br><span class="line">str==<span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h2 id="BufferedWriter"><a href="#BufferedWriter" class="headerlink" title="BufferedWriter"></a>BufferedWriter</h2><p>缓存输出类，加快输出速度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line">BufferedWriter out=<span class="keyword">new</span> <span class="title class_">BufferedWriter</span>( </span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line"><span class="comment">//要在方法后throws IOException</span></span><br><span class="line"><span class="comment">//写入，注意只能是String</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String str)</span>;</span><br><span class="line"><span class="comment">//换行</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">newLine</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><h2 id="StreamTokenizer"><a href="#StreamTokenizer" class="headerlink" title="StreamTokenizer"></a>StreamTokenizer</h2><p>输入流标记类，更快的读取速度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">StreamTokenizer</span> <span class="variable">IN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in)));</span><br><span class="line"><span class="comment">//自己实现的读整数方法，因为nval默认浮点，强制转型成整数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">readInt</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    IN.nextToken();</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>) IN.nval;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//读浮点方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">readDouble</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    IN.nextToken();</span><br><span class="line">    <span class="keyword">return</span> IN.nval;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//读字符串方法，注意是sval</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">readString</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    IN.nextToken();</span><br><span class="line">    <span class="keyword">return</span> IN.sval;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//判断结束</span></span><br><span class="line">IN.nextToken() != StreamTokenizer.TT_EOF;</span><br></pre></td></tr></table></figure><h2 id="PrintWriter"><a href="#PrintWriter" class="headerlink" title="PrintWriter"></a>PrintWriter</h2><p>另一个缓存输出类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">PrintWriter</span> <span class="variable">OUT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line"><span class="comment">//使用和System.out相同</span></span><br><span class="line">OUT.println();</span><br><span class="line">OUT.print();</span><br><span class="line"><span class="comment">//最后记得清缓存输出</span></span><br><span class="line">OUT.flush();</span><br></pre></td></tr></table></figure><h1 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h1><h2 id="窗口JFrame"><a href="#窗口JFrame" class="headerlink" title="窗口JFrame"></a>窗口JFrame</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Frame</span> <span class="keyword">extends</span> <span class="title class_">JFrame</span>&#123;</span><br></pre></td></tr></table></figure><p>创建一个新Frame类，继承预定义类JFrame，这样可以直接调用JFrame中方法而不用新创建JFrame对象<br>新定义方法：显示窗口<br>利用JFrame中预设的方法设置窗口的相关参数，忘记函数形参可以open declaration</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showUI</span><span class="params">()</span>&#123;</span><br></pre></td></tr></table></figure><p>设置窗口大小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setSize(<span class="number">800</span>，<span class="number">800</span>);</span><br></pre></td></tr></table></figure><p>设置标题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setTitle(<span class="string">&quot;窗口&quot;</span>);</span><br></pre></td></tr></table></figure><p>设置窗口居中显示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setLocationRelativeTo(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>设置退出方式，’3’为关闭窗口自动退出程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setDefaultCloseOperation(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>设置布局方式为流式布局<br><strong>注意</strong>：<strong>因为流式布局为一个预定义类，所以应该创建一个对象再将其设置为窗口布局</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setLayout(<span class="keyword">new</span> <span class="title class_">FlowLayout</span>());</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   其余函数体（为窗体添加其他元素）</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>设置窗口可见(<strong>写在添加元素之后，获取画笔之前</strong>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setVisible(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h2 id="按钮JButton"><a href="#按钮JButton" class="headerlink" title="按钮JButton"></a>按钮JButton</h2><p>&#x2F;&#x2F; 设置组件的坐标<br>void setLocation(int x, int y)<br>void setLocation(Point p)</p><p>&#x2F;&#x2F; 设置组件的宽高<br>void setSize(int width, int height)<br>void setSize(Dimension d)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Blog Test</title>
      <link href="/2023/03/21/Blog-Test/"/>
      <url>/2023/03/21/Blog-Test/</url>
      
        <content type="html"><![CDATA[<p><strong>Hello! Welcome to my blog!</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Google_Bigtable论文个人向笔记(补档)</title>
      <link href="/2021/08/10/Google-Bigtable%E8%AE%BA%E6%96%87%E4%B8%AA%E4%BA%BA%E5%90%91%E7%AC%94%E8%AE%B0-%E8%A1%A5%E6%A1%A3/"/>
      <url>/2021/08/10/Google-Bigtable%E8%AE%BA%E6%96%87%E4%B8%AA%E4%BA%BA%E5%90%91%E7%AC%94%E8%AE%B0-%E8%A1%A5%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Bigtable：分布式结构化数据存储系统"><a href="#Bigtable：分布式结构化数据存储系统" class="headerlink" title="Bigtable：分布式结构化数据存储系统"></a>Bigtable：分布式结构化数据存储系统</h1><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>用来处理海量数据：分布在数千台普通服务器上的PB级数据<br>（1PB&#x3D;1024TB 1EB&#x3D;1024PB 1ZB&#x3D;1024EB）<br>应用广泛，从搜索引擎到地图卫星图像。<br><strong>提供一个灵活的、高性能的解决方案，以满足在数据量和响应速度等方面具有差异性的应用需求</strong></p><h2 id="特点：高适用性、可扩展性、高性能、高可用性（灵活性）"><a href="#特点：高适用性、可扩展性、高性能、高可用性（灵活性）" class="headerlink" title="特点：高适用性、可扩展性、高性能、高可用性（灵活性）"></a>特点：高适用性、可扩展性、高性能、高可用性（灵活性）</h2><p>使用了一部分数据库的实现策略，但差别很大。<br><strong>不支持完整的关系数据模型，仅提供了简单的数据模型，通过此，用户可以动态控制数据的分布和格式。也就是对于Bigtable来说，数据只是单纯的数据，没有结构（Schema）。</strong><br>（对于schema我的理解是较为复杂的数据结构，例如图、树等）<br>我个人的理解是，因为该系统里面存储的都是数据量很大的table，所以叫Bigtable :)</p><h1 id="数据模型："><a href="#数据模型：" class="headerlink" title="数据模型："></a>数据模型：</h1><p><strong>Google SSTable文件格式：一个持久化的、排序的、不可更改的Map结构</strong><br><strong>其中的key有行、列和时间戳三个维度，value 是string（byte数组）<br><code>(row:string, column:string,time:int64)-&gt;string</code></strong></p><h2 id="行（row）："><a href="#行（row）：" class="headerlink" title="行（row）："></a>行（row）：</h2><p>行关键词是string，最高支持64kB   Bigtable通过行关键词的字典顺序来组织数据<br>在一行内的读写都是“原子”的（即可以对任何列进行操作）<br>在每一行中，可以进行数据的<strong>动态分区</strong>，形成“tablet”，提高读取访问效率。</p><h2 id="列（column）："><a href="#列（column）：" class="headerlink" title="列（column）："></a>列（column）：</h2><p>先分为最多几百个“<strong>列族</strong>”，每个列族再分成不同的列。<br>同一列族内的数据一般<strong>类型相同</strong>。列族的名字必须是可打印的字符串。列族必须先创建再使用，运行期间很少改变。<br>在每个列族之内，每个列有“<strong>限定词</strong>”是string。<br>访问控制、磁盘和内存统计都是在列族层面统计的。</p><h2 id="时间戳（time）："><a href="#时间戳（time）：" class="headerlink" title="时间戳（time）："></a>时间戳（time）：</h2><p>64位int ，精确到毫秒。<br>在相同的行列中，数据按时间戳倒序排列<br>有垃圾回收功能，有两个参数分别决定了数据保留时间和保留版数。</p><h2 id="硬件结构："><a href="#硬件结构：" class="headerlink" title="硬件结构："></a>硬件结构：</h2><p>从内部看，SSTable是一系列的数据块（通常每个块的大小是64KB，这个大小是可以配置的）<br>SSTable使用块索引（通常存储在SSTable的最后）来定位数据块，在打开SSTable的时候，索引被加载到内存。<br>每次查找都可以通过一次磁盘搜索完成：首先使用二分查找法在内存中的索引里找到数据块的位置，然后再从硬盘读取相应的数据块；也可以选择把整个SSTable都放在内存中，这样就不必访问硬盘了。</p><h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><p>在客户程序中，可以对Bigtable的数据进行如下操作：<br><strong>查找、遍历、添加、修改、删除</strong><br>例如论文中的c++代码：<br>可以通过先确定某一行(row)再确定该行内的某一列族(column family)的方式对数据进行操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Table *T = <span class="built_in">OpenOrDie</span>(<span class="string">&quot;/bigtable/web/webtable&quot;</span>);<span class="comment">//创建table指针对象</span></span><br><span class="line"><span class="function">RowMutation <span class="title">r1</span><span class="params">(T, <span class="string">&quot;com.cnn.www&quot;</span>)</span></span>;<span class="comment">//找到&quot;com.cnn.www&quot;对应行，创建行操作对象</span></span><br><span class="line">r1.<span class="built_in">Set</span>(<span class="string">&quot;anchor:www.c-span.org&quot;</span>, <span class="string">&quot;CNN&quot;</span>);<span class="comment">//找到&quot;anchor&quot;列族中&quot;www.c-span.org&quot;列，将内容替换</span></span><br><span class="line">r1.<span class="built_in">Delete</span>(<span class="string">&quot;anchor:www.abc.com&quot;</span>);<span class="comment">//删除&quot;anchor&quot;列族中&quot;www.abc.com&quot;列的内容</span></span><br></pre></td></tr></table></figure><p>也可以通过先确定某一列族再确定该列族的某一行的方式对数据进行操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Scanner <span class="title">scanner</span><span class="params">(T)</span></span>;<span class="comment">//创建用于扫描Bigtable的scanner对象</span></span><br><span class="line">ScanStream *stream;<span class="comment">//创建用于指向某一列族的stream指针对象</span></span><br><span class="line">stream = scanner.<span class="built_in">FetchColumnFamily</span>(<span class="string">&quot;anchor&quot;</span>);<span class="comment">//让stream指针指向&quot;anchor&quot;列族</span></span><br><span class="line">stream-&gt;<span class="built_in">SetReturnAllVersions</span>();<span class="comment">//设置让stream扫描时返回数据的所有版本？</span></span><br><span class="line">scanner.<span class="built_in">Lookup</span>(<span class="string">&quot;com.cnn.www&quot;</span>);<span class="comment">//找到&quot;com.cnn.www&quot;行</span></span><br><span class="line"><span class="keyword">for</span> (; !stream-&gt;<span class="built_in">Done</span>(); stream-&gt;<span class="built_in">Next</span>()) <span class="comment">//遍历该列族该行的所有列及其内容</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s %s %lld %s\n&quot;</span>,scanner.<span class="built_in">RowName</span>(),stream-&gt;<span class="built_in">ColumnName</span>(),stream-&gt;<span class="built_in">MicroTimestamp</span>(),stream-&gt;<span class="built_in">Value</span>());</span><br></pre></td></tr></table></figure><p>同时，Bigtable还提供跨行批量写入数据的接口，但暂不支持跨行事务处理<br>最后，Bigtable允许用户在服务器的地址空间内执行脚本程序</p><h1 id="组件介绍"><a href="#组件介绍" class="headerlink" title="组件介绍"></a>组件介绍</h1><p>Bigtable包括了三个主要的组件：链接到<strong>客户程序中的库</strong>、一个<strong>Master服务器</strong>和多个<strong>Tablet服务器</strong>。<br><strong>Tablet服务器：</strong> 管理一个Tablet集合（数十个到上千个），每个Tablet又会加载数个SSTable文件<br><strong>Master服务器：</strong> 为Tablet服务器分配Tablets、检测新加入的或者过期失效的Table服务<br>器、对Tablet服务器进行负载均衡<br><strong>客户程序中的库：</strong> 用于缓存用户Tablet的地址信息，如果没有缓存或者信息有误，则通过一个寻址算法与服务器通信重新获得。<br>客户端读取的数据都不经过Master服务器：客户程序直接和Tablet服务器通信进行读写操作。</p><p>除此之外，Bigtable还使用了一项名为Chubby的分布式锁服务组件，会在后文介绍。</p><h2 id="Bigtable数据结构"><a href="#Bigtable数据结构" class="headerlink" title="Bigtable数据结构"></a>Bigtable数据结构</h2><p><img src="https://img-blog.csdnimg.cn/c3436b43b7b54a20a3d0d4b90843c409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hlbmdpc3RfWg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Bigtable数据结构如图，一共有三层：<br>第一层是一个存储在Chubby中的文件，它包含了Root Tablet的位置信息。（Chubby介绍见后文）<br>第二层是一个名为METADATA的表，包含着所有Tablet。其第一项Root Tablet包含了一个特殊的table，记录着所有的Tablet的位置信息。<br>METADATA表的每个Tablet包含了一个用户所有Table的集合。第三层便是每个用户的Tables。</p><h2 id="Master与Tablet服务器"><a href="#Master与Tablet服务器" class="headerlink" title="Master与Tablet服务器"></a>Master与Tablet服务器</h2><p>一个Tablet只能分给一个Tablet服务器。当一个Tablet尚未被分配时，会由Master服务器向一个有足够空闲空间的Tablet服务器发送一个装载请求，将其分配。</p><p>当一个Tablet服务器启动时，它<strong>在Chubby的一个指定目录下建立一个有唯一性名字的文件</strong>，并且获取该文件的独占锁，BigTable由此跟踪记录Tablet服务器的状态：<br>当一个新的Tablet服务器加入时，一直监视Chubby中服务器目录的Master服务器会立刻得知。当一个Tablet服务器出现故障时，它与Chubby的会话将丢失。<br>如果Master服务器与一个Tablet服务器失联了，Master服务器会尝试在Chubby上获取该Tablet服务器的文件锁，如果获取成功，则将其删除并重新分配该服务器的所有Tablet。<br>Tablet服务器恢复时，会重新获取与Chubby的文件锁，如果获取失败则自行退出，会释放所有Tablet让Master服务器重新分配。</p><p>当一个Master服务器启动时，它会：1）从Chubby获取唯一Master锁以防止出现其他Master 2）从Chubby获取Tablet服务器列表 3）与每个Tablet服务器联系获取其Tablet存储信息 4）扫描Root Table得到未分配的Tablet并将其分配</p><h2 id="Tablet服务"><a href="#Tablet服务" class="headerlink" title="Tablet服务"></a>Tablet服务</h2><p>每一个用户的SSTable文件是保存在GFS之中的。读取时，Tablet服务器把SSTable的索引读进内存，之后在内存中进行构建。修改时，会先将更新操作提交到REDO日志中，之后存放于一个排序缓存最后进行提交。</p><h1 id="Big-Table功能与应用概述"><a href="#Big-Table功能与应用概述" class="headerlink" title="Big Table功能与应用概述"></a>Big Table功能与应用概述</h1><h2 id="优化功能"><a href="#优化功能" class="headerlink" title="优化功能"></a>优化功能</h2><p><strong>局部性群组：</strong> 将多个<strong>列族</strong>选出形成一个新的SSTable，以提高读取和操作效率。<br><strong>对SSTable的压缩：</strong> 客户端可以指定压缩模式，例如可以将多个局部性群组压缩，读取时只需解压其中一部分，以此提高访问效率。<br><strong>Bloom过滤器：</strong> 用于过滤空的行和列，以减少硬盘访问次数，提高检索速度<br><strong>Commit日志：</strong> 简而言之将对于Table的操作写进一个文件而不拆分，减少磁盘操作数量以提高普通操作的性能。</p><h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><p><strong>Google Analytics：</strong> 用来帮助Web站点的管理员分析他们网站的流量模式，比如用户数量、URL浏览次数、用户行为统计报告等…<br><strong>Google Earth：</strong> 高分辨率的地球表面卫星图像<br><strong>Google Personal Search（个性化查询）：</strong> 该服务记录着yoghurt使用过的各种google服务，例如Web查询、图像和新闻。用户可以通过该服务重复之前的查询和点击，google也可以通过此为用户定制与推荐个性化服务。</p><h1 id="补充：分布式系统"><a href="#补充：分布式系统" class="headerlink" title="补充：分布式系统"></a>补充：分布式系统</h1><h2 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h2><p><strong>集中式系统：</strong> 由一台或多台主计算机组成<strong>中心节点</strong>，满足<strong>数据的集中存储</strong>、<strong>业务单元的集中部署</strong>、<strong>系统功能的集中处理</strong>。<br>优点：结构简单、部署简单、架构简单<br>缺点：大型机价格昂贵、容错率低（单点故障则服务终止）、研发成本高且性能受限于摩尔定律</p><p><strong>分布式系统：</strong> 一个<strong>硬件或软件分布在不同的网络计算机上</strong>，彼此间<strong>仅仅通过消息传递进行通信和协调</strong>的系统。 <strong>物理上的多台主机组建成一个逻辑上的单台主机。</strong> 有如下特点：<br><strong>分布性</strong>：多台计算机在空间上随意分布，且分布情况随时变动<br><strong>对等性</strong>：集群中的每个工作节点的优先级是一样的，即各个节点 <strong>互为副本</strong><br><strong>并发性</strong>： 多个节点<strong>同时操作</strong>一个数据库或者存储系统<strong>可能引发数据不一致</strong><br><strong>同步性差</strong>：缺乏全局时钟，多个主机上<strong>事件的先后顺序难以界定</strong></p><h2 id="相关概念："><a href="#相关概念：" class="headerlink" title="相关概念："></a>相关概念：</h2><p><strong>并行</strong>(parallelism)：在<strong>多处理器</strong>系统中同时运行<strong>多个线程</strong>，且不会互相抢占cpu资源<br><strong>并发</strong>(concurrency)：在<strong>单处理器</strong>系统中同时运行<strong>多个线程</strong>，由操作系统负责调度cpu资源使得同一时间线程都处于运行状态<br><strong>同步</strong>(synchronous)：在进程（程序）执行IO（与外部数据交互）时，线程处于等待状态<br><strong>异步</strong>(asynchronous)：在进程的IO尚未完成时，线程已经开始运行<br><strong>阻塞</strong>(blocking)：在进程发出指令后，等待cpu处理完成后再进行后面操作<br><strong>非阻塞</strong>(nonblocking)：进程发出指令后，直接继续，过一段时间再回来问cpu是否处理完成（轮询）</p><h2 id="分布式系统性能指标："><a href="#分布式系统性能指标：" class="headerlink" title="分布式系统性能指标："></a>分布式系统性能指标：</h2><p><strong>吞吐能力</strong>：每秒可以处理的数据量<br><strong>响应延迟</strong>：完成某一功能所需要时间<br><strong>并发能力</strong>：同时完成多种功能的能力（QPS：每秒响应次数）<br><strong>可用性（可靠性）</strong>：系统容错能力（面对异常时的服务能力），可以由停服务时间与正常服务时间比例衡量<br><strong>可扩展性</strong>：系统中可以随着集群中的机器数量线性增长的指标<br><strong>一致性</strong>：读和写操作之间的延时（强一致性指写操作完成后可以立刻读到、弱一致性则需要经过一段时间）读写一致性：对于单个用户的强一致性。最终一致性：最差的一致性，因为优先考虑高并发能力<br>以上所有性能不能兼得，在不同的应用场景下必然会有取舍。</p><h2 id="分布式事物"><a href="#分布式事物" class="headerlink" title="分布式事物"></a>分布式事物</h2><p>：多个节点同时执行的事物，必须满足<strong>ACID</strong>（原子性、一致性、持久性、隔离性）<br>为了保证事物的ACID特性，需要引入一个<strong>协调者</strong>节点（Cooradinator）来调度所有节点的行为，而其他的节点被称作<strong>参与者</strong></p><h2 id="2PC（二阶段提交协议）"><a href="#2PC（二阶段提交协议）" class="headerlink" title="2PC（二阶段提交协议）"></a>2PC（二阶段提交协议）</h2><p>1、<strong>请求&#x2F;表决阶段</strong>：协调者节点得到请求后，向所有参与者节点发送事物<strong>预处理请求</strong>(vote request)<br>此时对于每个参与者，<strong>如果可以执行请求则立刻执行</strong>，写入<strong>undo</strong>和<strong>redo</strong>日志，执行完成后向协调者返回“YES”；<strong>如果不能执行则立刻返回“NO”</strong><br>（undo日志用于保存被修改前的数据，如果执行“回滚(rollback)”操作则将undo中数据覆盖回去即撤销修改；执行修改操作时，如果将数据逐个放入磁盘效率太低且容错较差，所以先将修改后的数据写入redo日志最后统一录入磁盘）<br>2、<strong>提交&#x2F;回滚阶段</strong>：经过一段时间后，如果协调者接收到了所有“YES”，则向所有参与者发送 <strong>“正式提交”(commit)请求</strong>，此时所有参与者会释放资源并返回“ACK”，接收到所有“ACK”后协调者向上报告完成请求；如果收到“NO”，则向所有参与者发送 <strong>“回滚”(rollback)请求</strong>，此时所有参与者执行“回滚”并释放资源，返回“ACK”，接收到所有“ACK”后协调者上报请求失败或超时。<br>(ACK指 Acknowledgement即确认字符，表示操作已经完成)</p><p><strong>问题</strong>：<br>1、由于在执行期间所有参与者都处于阻塞状态，直至协调者发指令，所有参与者节点都占用着资源，对性能影响较大（<strong>同步阻塞</strong>）<br>2、一旦协调者出现故障，无法发出指令时会导致所有参与者一直处于等待状态，对性能影响较大（<strong>协调者宕机</strong>）<br>3、在二阶段的指令发出后，如果此时网络故障会导致一部分参与者无法收到指令，导致数据不一致（<strong>消息丢失</strong>）<br>4、任何一个参与者响应未收到，则整个事物失败（<strong>容错率低</strong>）</p><h2 id="3PC（三阶段提交协议）"><a href="#3PC（三阶段提交协议）" class="headerlink" title="3PC（三阶段提交协议）"></a>3PC（三阶段提交协议）</h2><p>1、<strong>提交询问阶段(canCommit)<strong>：<br>协调者节点得到请求后，向所有参与者发送提交询问，此时对于每个参与者，如果可以执行请求则立刻返回“YES”（</strong>注意此时不执行</strong>），如果不能则立刻返回“NO”<br>2、<strong>预提交阶段(preCommit)<strong>：<br>经过一段时间后，如果协调者接收到了所有“YES”，则向所有参与者发送 “预提交”(preCommit)请求，此时对于每个参与者开始执行，写入undo和redo日志，</strong>如果在执行过程中出错则返回“NO”</strong>，执行完成后返回“ACK”<br>3、<strong>最终提交阶段(doCommit)<strong>：<br>又经过了一段时间后，如果协调者接收到了所有“ACK”，则向所有参与者发送“提交”请求，此时所有参与者会释放资源并返回“ACK”，接收到所有“ACK”后协调者向上报告完成请求；如果收到“NO”或者在时限内没收到所有“YES”（</strong>3PC引入超时机制</strong>），则向所有参与者发送 <strong>“回滚”(rollback)请求</strong>，此时所有参与者执行“回滚”并释放资源，返回“ACK”，接收到所有“ACK”后协调者上报请求失败或超时。</p><p><strong>问题：</strong><br>1、降低阻塞范围，但仍然存在<br>2、协调者宕机的问题仍然存在<br>3、容错率问题未得到改善</p><h2 id="Paxos算法"><a href="#Paxos算法" class="headerlink" title="Paxos算法"></a>Paxos算法</h2><p>无论2PC还是3PC都无法彻底解决分布性一致性问题以及容错率都较低，于是便引出了Paxos算法。</p><p><strong>概述：</strong><br><strong>Paxos算法是基于消息传递且具有高度容错性的一致性算法。</strong><br>其解决的问题就是在一旦发生异常（包括消息的延迟、丢失、重复、乱序等）的分布式系统中，快速且正确地在集群内部对某个决议达成一致。<br>在每一条指令时，都要执行一次一致性算法。<br>假如在分布式系统中初始是各个节点的数据是一致的，每个节点都顺序执行系列操作，然后每个节点最终的数据还是一致的。<br>Paxos算法的前提是信道可靠，即发出的信号不会被篡改。通常来说，大多数系统都是部署在一个局域网之中，并且存在一套用于校验文件完整性的算法，所以在实际工程中可以假设信道可靠。</p><p><strong>相关概念：</strong><br>在Paxos算法中，存在三种角色（一个进程可以同时充当多种角色）：<br><strong>提议者</strong>（Proposer）负责提出提案<br><strong>接受者</strong>（Acceptor）负责对提案做出裁决（是否接受）<br><strong>学习者</strong>（Learner）负责学习提案结果<br><strong>提案</strong>（Proposal）每一个提案都对应一个value（指令）</p><p><strong>过程：</strong><br><strong>阶段一</strong>（prepare阶段）<br>Proposer选择一个编号为N的提案，并向半数以上的Acceptor发送编号为N的Prepare请求<code>Prepare(N)</code></p><p>每个Acceptor中有一个<code>maxN</code>参数，记录着到<strong>目前为止接受过的最大编号提案的编号</strong>。在收到<code>Prepare(N)</code>后:<br><code>if(maxN==null)</code> 回应<code>pok</code>（prepare ok）<br><code>if(maxN&gt;N)</code> 不回应或者回复<code>error1</code><br><code>if(maxN&lt;N)</code> <code>maxN=N</code>并回应<code>pok</code></p><p><strong>阶段二</strong>（accept阶段）<br>Proposer如果没收到半数以上的<code>pok</code>，则更换提案（更大N值）回到阶段一。<br>如果收到了半数以上的<code>pok</code>，则向半数以上的Acceptor发送包含<code>&lt;N,value&gt;</code>的Accept请求<code>Accept(N)</code></p><p>Acceptor在收到<code>Accept(N)</code>后<br><code>if(maxN&gt;N)</code> 不回应或者回复<code>error2</code><br><code>if(maxN&lt;=N)</code> 回应<code>aok</code> （accept ok）</p><p>Proposer如果没收到半数以上的<code>aok</code>，则更换提案（更大N值）回到阶段一。<br>如果收到了半数以上的<code>aok</code>，则向所有的Learner发送<code>value</code> 算法结束。</p><h1 id="Chubby系统"><a href="#Chubby系统" class="headerlink" title="Chubby系统"></a>Chubby系统</h1><p>Chubby是一个“<strong>高可用的、序列化的分布式锁服务组件</strong>”。<br><strong>Chubby的底层一致性实现就是以Paxos算法为基础的</strong>。<br>Chubby系统架构分为了两部分：<strong>服务端</strong>被称为Chubby cell和<strong>客户端</strong>（Client）<br><strong>客户端：</strong> 包含了名为Chubby library接口，调用后可以在Chubby cell上创建文件并实现锁的功能</p><h2 id="Chubby-cell"><a href="#Chubby-cell" class="headerlink" title="Chubby cell"></a>Chubby cell</h2><p>一个Chubby cell由五台服务器组成，可以支持整个数据中心的锁服务，其中每台服务器被称作<strong>副本</strong>（replicas）<br>在Chubby cell工作时，先选出一个master服务器，所有的服务器都将维护同一份DB拷贝，但只有master能够接受客户端的请求对DB进行读写，其余四个副本只能接受master的指令对备份DB进行修改。<br>一旦master出现故障，其他副本将立刻选出一个新的master进行替代。</p><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>Chubby的底层实际上是一个文件系统，提供了一个命名空间，里面包括了目录和小文件。每个目录或者文件可以当成一个锁，读写文件的操作都是原子的。Chubby的文件系统由于它的特殊用途做了很多的简化。例如它不支持文件的转移，不记录文件最后访问时间等等。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
